<!DOCTYPE html>
  <head>
    <title>Интерактивный учебник</title>
    <meta name="keywords" content="" />
	<meta name="description" content="" />
    <!-- 
    Polygon Template
    https://templatemo.com/tm-400-polygon
    -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- Bootstrap -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="css/templatemo_misc.css">
    <link href="css/templatemo_style.css" rel="stylesheet">
    <link href='http://fonts.googleapis.com/css?family=Raleway:400,100,600' rel='stylesheet' type='text/css'>
      
    <script src="js/jquery-1.10.2.min.js"></script> 
	<script src="js/jquery.lightbox.js"></script>
	<script src="js/templatemo_custom.js"></script>
    <script>
    function showhide()
    {
    	var div = document.getElementById("newpost");
		if (div.style.display !== "none")
		{
			div.style.display = "none";
		}
		else {
			div.style.display = "block";
		}
    }
  	</script>
  </head>
  <body>
  	<div class="site-header">
		<div class="main-navigation">
			<div class="responsive_menu">
				<ul>
					<li><a href="index.html">На главную</a></li>
				</ul>
			</div>
			<div class="container">
				<div class="row templatemo_gallerygap">
					<div class="col-md-12 responsive-menu">
						<a href="#" class="menu-toggle-btn">
				            <i class="fa fa-bars"></i>
				        </a>
					</div> <!-- /.col-md-12 -->
                    <div class="col-md-3 col-sm-12">
                    	<a href="index.html"><img src="images/templatemo_logo.png" alt="Polygon HTML5 Template"></a>
                    </div>
					<div class="col-md-9 main_menu">
						<ul>
							<li><a href="index.html">
                            	<span class="fa fa-book"></span>
                                На главную</a></li>
						</ul>
					</div> <!-- /.col-md-12 -->
				</div> <!-- /.row -->
			</div> <!-- /.container -->
		</div> <!-- /.main-navigation -->
	</div> <!-- /.site-header -->
    <div id="menu-container">
    <!-- gallery start -->
     <div class="container">
		 <h2>15. Реализация параллелизма в Occam, Ada, Java.</h2>
		 <a class="fa fa-book" href="https://ru.wikipedia.org/wiki/Occam"> Источник 1</a>
		 |
		 <a class="fa fa-book" href="https://ru.wikipedia.org/wiki/%D0%90%D0%B4%D0%B0_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)"> Источник 2</a>
		 |
		 <a class="fa fa-book" href="https://habr.com/ru/post/164487/"> Источник 3</a>

		 <h4>Occam</h4>
		 <p><b>Occam</b> -  процедурный язык параллельного программирования высокого уровня, разработанный в начале 1980-х годов группой учёных из Оксфорда под руководством Дэвида Мэя по заданию английской компании INMOS Ltd. в рамках работ по созданию транспьютеров. Назван в честь английского философа XIV века Уильма Оккамского, а его сентенция, известная как бритва Оккама, является девизом проекта.</p>
		 <p>Между языком Оккам и транспьютерами существует непосредственная связь: INMOS-транспьютеры спроектированы так, чтобы объекты и конструкции Occam’а реализовывались в их системе команд наилучшим образом. Фактически, транспьютер является «кремниевой реализацией» языка Оккам. Долгое время INMOS утверждала, что транспьютерам не требуется система программирования типа «ассемблер», так как её вполне заменяет Occam.</p>
		 <p>Тем не менее, Оккам является типичным языком высокого уровня, синтаксически похожим на Паскаль или Си.</p>
		 <h3>Теоретические основы</h3>
		 <p>В основе языка лежит так называемая CSP-концепция (концепция взаимодействующих последовательных процессов), разработанная Ч. Хоаром. В сущности, CSP — это формализм для описания соответствующей вычислительной модели, достаточно выразительный, чтобы на нём можно было записывать и доказывать теоремы, и достаточно мощный и однозначный, чтобы являться языком программирования (известно несколько реализаций). Согласно CSP, сначала вводится множество элементарных событий (алфавит), затем из них конструируются процессы, причём из только что описанных процессов можно строить новые. Процессы, протекающие параллельно, обмениваются информацией, используя безбуферный обмен информацией типа «рандеву» между парой (и только парой) процессов посредством специального объекта — канала. При взаимодействии тот участник обмена, который обратился к каналу первым, ожидает готовности партнёра (точки рандеву); при наступлении последней инициируется обмен. Использование общей для нескольких параллельных процессов памяти в CSP не допускается.</p>
		 <h3>Синтаксис и семантика</h3>
		 <p>Базовым понятием языка Оккам является вычислительный процесс; основной характеристикой процесса является то, что он может быть начат и завершён. В языке определено несколько простых процессов: процесс присваивания, процессы ввода и вывода через канал (обозначаются символами ? и !), формальные процессы SKIP и STOP (первый завершается сразу же, второй — никогда), процессы чтения таймера и таймерной задержки. Все остальные процессы могут быть получены иерархическим построением (через ранее определённые). Для этой цели Оккам предоставляет набор конструкторов процессов: SEQ (определяет процесс последовательного выполнения процессов), PAR (определяет процесс параллельного выполнения процессов), а также конструктор условного процесса IF, циклического процесса WHILE, процесса выбора процессов ALT. При этом действует правило, согласно которому составной процесс типа SEQ или PAR считается выполненным, когда завершены все составляющие его процессы. Процессы могут быть поименованы и вызваны по имени с передачей параметров. Процессы SEQ, PAR, IF и ALT могут быть реплицированы (размножены) при помощи репликатора FOR. Процесс ALT (как и PAR) привносит в язык индетерминизм, так как считается, что при одновременном выполнении нескольких условий точно предсказать дальнейший ход событий невозможно.</p>
		 <pre>пример:
  Мультиплексор, бесконечно читающий из массива каналов in[] и передающий в общий канал out,
  используя промежуточную переменную temp
     WHILE TRUE
       INT temp :
       ALT i=0 FOR N
         in[i] ? temp
           out ! temp</pre>
		 <pre>пример:
  Каскад параллельно работающих мультиплексоров.
  На входе — массив из M*N каналов in[], на выходе — канал out.
  Массив из M каналов ch[] используется для связи между мультиплексорами каскада:
     PAR -- каскад параллельных мультиплексоров ввода
       PAR i=0 FOR M -- M параллельных мультиплексоров, обрабатывающих по N каналов из in[] каждый
         WHILE TRUE
           INT temp :
           ALT j=i*N FOR N
             in[j] ? temp
               ch[i] ! temp
       WHILE TRUE -- корневой мультиплексор, читающий M промежуточных каналов ch[]
         INT temp :
         ALT i=0 FOR M
           ch[i] ? temp
             out ! temp</pre>
		 <pre>пример:
  Процесс буферизации ввода-вывода.
  Запуск процесса buffer( in, out, N) позволяет каналу out отстать от канала in
  вплоть на N сообщений, которые будут буферизованы внутри процесса buffer:
     PROC buffer( CHAN OF INT in, out, INT N)
       CHAN OF INT in.wait, out.wait :
       INT n : -- счётчик буферизованных значений
       [N]INT buff :
       SEQ
         n:=0
         PAR—input
           INT i, any: -- i — указатель записи в буфер
           SEQ
             i:=0
             WHILE TRUE
               SEQ
                 WHILE n<(N-1)
                   SEQ
                     in ? buff[i]
                     n:=n+1
                     IF
                       n=1
                         out.wait ! any
                       TRUE
                         SKIP
                     i:=(i+1) MOD N
                 in.wait ? any—output
           INT j, any: -- j — указатель чтения из буфера
           SEQ
             j:=0
             WHILE TRUE
               SEQ
                 out.wait ? any
                 WHILE n>0
                   SEQ
                     out ! buff[j]
                     n:=n-1
                     IF
                       n=(N-2)
                         in.wait ! any
                       TRUE
                         SKIP
                     j:=(j+1) MOD N
     :</pre>
		 <p>Изучая примеры, следует иметь в виду, что символ «два минуса» -- означает начало комментария до конца строки, а символ «точка» . может быть в Оккаме частью идентификатора и не несёт никакой специальной нагрузки. Символ «двоеточие» : имеет значение «конец описания». Оссам чувствителен к заглавным/строчным буквам в идентификаторах.</p>
		 <p>Интересной особенностью языка Occam является включение индентации (отступов, «лесенки») в его синтаксис. Это популярное и весьма выразительное средство выделения структуры в Оккаме является единственным способом указания области действия конструкторов. В ряду безусловных достоинств такого решения можно назвать уменьшение количества служебных символов при записи конструкции (отпадает необходимость в словах типа BEGIN-END или фигурных скобках) и вынужденная стандартизация оформления текстов, что повышает их читабельность.</p>
		 <p>Пример важности «лесенки»:</p>
		 <pre>SEQ
      proc1()
      PAR
        proc21()
        proc22()
      proc3()</pre>
		 <p>здесь сначала будет выполнен процесс proc1, затем будут параллельно исполняться proc21 и proc22, и лишь после завершения самого длительного из них стартует proc3. Если сдвинуть вызов proc3 на уровень вправо, то порядок вычислений меняется:</p>
		 <pre>SEQ
      proc1()
      PAR
        proc21()
        proc22()
        proc3()</pre>
		 <p>Здесь proc3 стартует одновременно с proc21 и proc22.</p>
		 <h4>Ada</h4>
		 <p><b>Ада (Ada)</b> — язык программирования, созданный в 1979—1980 годах в ходе проекта Министерством обороны США с целью разработать единый язык программирования для встроенных систем (то есть систем управления автоматизированными комплексами, функционирующими в реальном времени). Имелись в виду прежде всего бортовые системы управления военными объектами (кораблями, самолётами, танками, ракетами, снарядами и т. п.). Перед разработчиками не стояло задачи создать универсальный язык, поэтому решения, принятые авторами Ады, нужно воспринимать в контексте особенностей выбранной предметной области.</p>
		 <h3>Особенности</h3>
		 <p>В исходном варианте, стандартизованном в 1983 году, Ада — это структурный, модульный язык программирования, содержащий высокоуровневые средства программирования параллельных процессов. Синтаксис Ады унаследован от языков типа Algol или Паскаль, но расширен, а также сделан более строгим и логичным. Ада — язык со строгой типизацией, в нём исключена работа с объектами, не имеющими типов, а автоматические преобразования типов сведены к абсолютному минимуму: допускается неявное приведение значения общего целого или вещественного числового типа к совместимому числовому типу[6]. В стандарте 1995 года в язык были добавлены базовые средства объектно-ориентированного программирования, в стандарте 2007 эти средства были дополнены, поэтому современная Ада — объектно-ориентированный язык программирования.</p>
		 <h3>Синтаксис</h3>
		 <p>В язык встроены конструкции поддержки параллельного программирования: поддерживаются понятия «задача» (параллельно выполняемый фрагмент программы), «вход задачи» (средство синхронизации и коммуникации параллельно выполняющихся задач), поддерживается механизм «рандеву» (протокол взаимодействия параллельно выполняемых задач через вход одной из них), имеется оператор выбора SELECT для организации условного межпотокового взаимодействия (выбора параллельной задачи, с которой следует взаимодействовать, в зависимости от готовности к рандеву и некоторых других условий). В принципе, имеющихся в языке средств параллельного программирования достаточно для решения большого класса задач, требующих параллельной обработки, без обращения к внешним средствам, таким как дополнительные библиотеки или API операционной системы.</p>
		 <h3>Пример</h3>
		 <p>Буфер на один слот, то есть инкапсулированную переменную, значения которой могут вставляться и удаляться строго поочередно. Обратите внимание, что буферная задача не нуждается в переменных состояния для реализации протокола буфера: чередование операций вставки и удаления напрямую обеспечивается структурой управления в теле Encapsulated_Buffer_Task_Type, которое, как обычно, является циклом .</p>
		 <pre> task type Encapsulated_Buffer_Task_Type is
     entry Insert (An_Item : in  Item);
     entry Remove (An_Item : out Item);
  end Encapsulated_Buffer_Task_Type;
  ...
  Buffer_Pool : array (0 .. 15) of Encapsulated_Buffer_Task_Type;
  This_Item   : Item;
  ...
  task body Encapsulated_Buffer_Task_Type is
     Datum : Item;
  begin
     loop
        accept Insert (An_Item : in  Item) do
           Datum := An_Item;
        end Insert;
        accept Remove (An_Item : out Item) do
           An_Item := Datum;
        end Remove;
     end loop;
  end Encapsulated_Buffer_Task_Type;
  ...
  Buffer_Pool(1).Remove (This_Item);
  Buffer_Pool(2).Insert (This_Item);</pre>
		 <h4>Java</h4>
		 <h3>Многопоточность</h3>
		 <p>Наиболее очевидная область применения многопоточности – это программирование интерфейсов. Многопоточность незаменима тогда, когда необходимо, чтобы графический интерфейс продолжал отзываться на действия пользователя во время выполнения некоторой обработки информации. Например, поток, отвечающий за интерфейс, может ждать завершения другого потока, загружающего файл из интернета, и в это время выводить некоторую анимацию или обновлять прогресс-бар. Кроме того он может остановить поток загружающий файл, если была нажата кнопка «отмена».</p>
		 <h3>Запуск потоков</h3>
		 <p>Каждый процесс имеет хотя бы один выполняющийся поток. Тот поток, с которого начинается выполнение программы, называется главным. В языке Java, после создания процесса, выполнение главного потока начинается с метода main(). Затем, по мере необходимости, в заданных программистом местах, и при выполнении заданных им же условий, запускаются другие, побочные потоки.</p>
		 <p>В языке Java поток представляется в виде объекта-потомка класса Thread. Этот класс инкапсулирует стандартные механизмы работы с потоком.</p>
		 <p>Запустить новый поток можно двумя способами:</p>
		 <h3>Способ 1</h3>
		 <p>Создать объект класса Thread, передав ему в конструкторе нечто, реализующее интерфейс Runnable. Этот интерфейс содержит метод run(), который будет выполняться в новом потоке. Поток закончит выполнение, когда завершится его метод run().</p>
		 <p>Выглядит это так:</p>
		 <pre>class SomeThing					//Нечто, реализующее интерфейс Runnable
implements Runnable				//(содержащее метод run())
{
	public void run()			//Этот метод будет выполняться в побочном потоке
	{
		System.out.println("Привет из побочного потока!");
	}
}

public class Program				//Класс с методом main()
{
	static SomeThing mThing;		//mThing - объект класса, реализующего интерфейс Runnable

	public static void main(String[] args)
	{
		mThing = new SomeThing();

		Thread myThready = new Thread(mThing);	//Создание потока "myThready"
		myThready.start();				//Запуск потока

		System.out.println("Главный поток завершён...");
	}
}</pre>
		 <p>Для пущего укорочения кода можно передать в конструктор класса Thread объект безымянного внутреннего класса, реализующего интерфейс Runnable:</p>
		 <pre>public class Program				//Класс с методом main().
{
 public static void main(String[] args)
	{
		//Создание потока
		Thread myThready = new Thread(new Runnable()
		{
			public void run() //Этот метод будет выполняться в побочном потоке
			{
				System.out.println("Привет из побочного потока!");
			}
		});
		myThready.start();	//Запуск потока

		System.out.println("Главный поток завершён...");
	}
}</pre>
		 <h3>Способ 2</h3>
		 <p>Создать потомка класса Thread и переопределить его метод run():</p>
		 <pre>class AffableThread extends Thread
{
	@Override
	public void run()	//Этот метод будет выполнен в побочном потоке
	{
		System.out.println("Привет из побочного потока!");
	}
}

public class Program
{
	static AffableThread mSecondThread;

	public static void main(String[] args)
	{
		mSecondThread = new AffableThread();	//Создание потока
		mSecondThread.start();					//Запуск потока

		System.out.println("Главный поток завершён...");
	}
}</pre>
		 <p>В приведённом выше примере в методе main() создается и запускается еще один поток. Важно отметить, что после вызова метода mSecondThread.start() главный поток продолжает своё выполнение, не дожидаясь пока порожденный им поток завершится. И те инструкции, которые идут после вызова метода start(), будут выполнены параллельно с инструкциями потока mSecondThread.</p>
		 <p>Для демонстрации параллельной работы потоков давайте рассмотрим программу, в которой два потока спорят на предмет философского вопроса «что было раньше, яйцо или курица?». Главный поток уверен, что первой была курица, о чем он и будет сообщать каждую секунду. Второй же поток раз в секунду будет опровергать своего оппонента. Всего спор продлится 5 секунд. Победит тот поток, который последним изречет свой ответ на этот, без сомнения, животрепещущий философский вопрос. В примере используются средства, о которых пока не было сказано (isAlive() sleep() и join()). К ним даны комментарии, а более подробно они будут разобраны дальше.</p>
		 <pre>class EggVoice extends Thread
{
	@Override
	public void run()
	{
		for(int i = 0; i < 5; i++)
		{
			try{
				sleep(1000);		//Приостанавливает поток на 1 секунду
			}catch(InterruptedException e){}

			System.out.println("яйцо!");
		}
		//Слово «яйцо» сказано 5 раз
	}
}

public class ChickenVoice	//Класс с методом main()
{
	static EggVoice mAnotherOpinion;	//Побочный поток

	public static void main(String[] args)
	{
		mAnotherOpinion = new EggVoice();	//Создание потока
		System.out.println("Спор начат...");
		mAnotherOpinion.start(); 			//Запуск потока

		for(int i = 0; i < 5; i++)
		{
			try{
				Thread.sleep(1000);		//Приостанавливает поток на 1 секунду
			}catch(InterruptedException e){}

			System.out.println("курица!");
		}

		//Слово «курица» сказано 5 раз

		if(mAnotherOpinion.isAlive())	//Если оппонент еще не сказал последнее слово
		{
			try{
				mAnotherOpinion.join();	//Подождать пока оппонент закончит высказываться.
			}catch(InterruptedException e){}

			System.out.println("Первым появилось яйцо!");
		}
		else	//если оппонент уже закончил высказываться
		{
			System.out.println("Первой появилась курица!");
		}
		System.out.println("Спор закончен!");
	}
}

Консоль:
Спор начат...
курица!
яйцо!
яйцо!
курица!
яйцо!
курица!
яйцо!
курица!
яйцо!
курица!
Первой появилась курица!
Спор закончен!</pre>
		 <p>В приведенном примере два потока параллельно в течении 5 секунд выводят информацию на консоль. Точно предсказать, какой поток закончит высказываться последним, невозможно. Можно попытаться, и можно даже угадать, но есть большая вероятность того, что та же программа при следующем запуске будет иметь другого «победителя». Это происходит из-за так называемого «асинхронного выполнения кода». Асинхронность означает то, что нельзя утверждать, что какая-либо инструкция одного потока, выполнится раньше или позже инструкции другого. Или, другими словами, параллельные потоки независимы друг от друга, за исключением тех случаев, когда программист сам описывает зависимости между потоками с помощью предусмотренных для этого средств языка.</p>
		 <h3>Завершение процесса и "демоны"</h3>
		 <p>В Java процесс завершается тогда, когда завершается последний его поток. Даже если метод main() уже завершился, но еще выполняются порожденные им потоки, система будет ждать их завершения.</p>
		 <p>Однако это правило не относится к особому виду потоков – демонам. Если завершился последний обычный поток процесса, и остались только потоки-демоны, то они будут принудительно завершены и выполнение процесса закончится. Чаще всего потоки-демоны используются для выполнения фоновых задач, обслуживающих процесс в течение его жизни.</p>
		 <p>Объявить поток демоном достаточно просто — нужно перед запуском потока вызвать его метод <b>setDaemon(true)</b>;</p>
		 <p>Проверить, является ли поток демоном, можно вызвав его метод <b>boolean isDaemon()</b>;</p>
		 <h3>Завершение потоков</h3>
		 <p>В Java существуют (существовали) средства для принудительного завершения потока. В частности метод Thread.stop() завершает поток незамедлительно после своего выполнения. Однако этот метод, а также Thread.suspend(), приостанавливающий поток, и Thread.resume(), продолжающий выполнение потока, были объявлены устаревшими и их использование отныне крайне нежелательно. Дело в том что поток может быть «убит» во время выполнения операции, обрыв которой на полуслове оставит некоторый объект в неправильном состоянии, что приведет к появлению трудноотлавливаемой и случайным образом возникающей ошибке.</p>
		 <p>Вместо принудительного завершения потока применяется схема, в которой каждый поток сам ответственен за своё завершение. Поток может остановиться либо тогда, когда он закончит выполнение метода run(), (main() — для главного потока) либо по сигналу из другого потока. Причем как реагировать на такой сигнал — дело, опять же, самого потока. Получив его, поток может выполнить некоторые операции и завершить выполнение, а может и вовсе его проигнорировать и продолжить выполняться. Описание реакции на сигнал завершения потока лежит на плечах программиста.</p>
		 <p>Java имеет встроенный механизм оповещения потока, который называется Interruption (прерывание, вмешательство), и скоро мы его рассмотрим, но сначала посмотрите на следующую программку:</p>
		 <p>Incremenator — поток, который каждую секунду прибавляет или вычитает единицу из значения статической переменной Program.mValue. Incremenator содержит два закрытых поля – mIsIncrement и mFinish. То, какое действие выполняется, определяется булевой переменной mIsIncrement — если оно равно true, то выполняется прибавление единицы, иначе — вычитание. А завершение потока происходит, когда значение mFinish становится равно true.</p>
		 <pre>class Incremenator extends Thread
{
	//О ключевом слове volatile - чуть ниже
	private volatile boolean mIsIncrement = true;
	private volatile boolean mFinish = false;

	public void changeAction()	//Меняет действие на противоположное
	{
		mIsIncrement = !mIsIncrement;
	}
	public void finish()		//Инициирует завершение потока
	{
		mFinish = true;
	}

	@Override
	public void run()
	{
		do
		{
			if(!mFinish)	//Проверка на необходимость завершения
			{
				if(mIsIncrement)
					Program.mValue++;	//Инкремент
				else
					Program.mValue--;	//Декремент

				//Вывод текущего значения переменной
				System.out.print(Program.mValue + " ");
			}
			else
				return;		//Завершение потока

			try{
				Thread.sleep(1000);		//Приостановка потока на 1 сек.
			}catch(InterruptedException e){}
		}
		while(true);
	}
}

public class Program
{
	//Переменая, которой оперирует инкременатор
	public static int mValue = 0;

	static Incremenator mInc;	//Объект побочного потока

	public static void main(String[] args)
	{
		mInc = new Incremenator();	//Создание потока

		System.out.print("Значение = ");

		mInc.start();	//Запуск потока

		//Троекратное изменение действия инкременатора
		//с интервалом в i*2 секунд
		for(int i = 1; i <= 3; i++)
		{
			try{
				Thread.sleep(i*2*1000); //Ожидание в течении i*2 сек.
			}catch(InterruptedException e){}

			mInc.changeAction();	//Переключение действия
		}

		mInc.finish();	//Инициация завершения побочного потока
	}
}

Консоль:
Значение = 1 2 1 0 -1 -2 -1 0 1 2 3 4</pre>
		 <p>Взаимодействовать с потоком можно с помощью метода changeAction() (для смены вычитания на сложение и наоборот) и метода finish() (для завершения потока).</p>
		 <p>В объявлении переменных mIsIncrement и mFinish было использовано ключевое слово volatile (изменчивый, не постоянный). Его необходимо использовать для переменных, которые используются разными потоками. Это связано с тем, что значение переменной, объявленной без volatile, может кэшироваться отдельно для каждого потока, и значение из этого кэша может различаться для каждого из них. Объявление переменной с ключевым словом volatile отключает для неё такое кэширование и все запросы к переменной будут направляться непосредственно в память.</p>
		 <p>В этом примере показано, каким образом можно организовать взаимодействие между потоками. Однако есть одна проблема при таком подходе к завершению потока — Incremenator проверяет значение поля mFinish раз в секунду, поэтому может пройти до секунды времени между тем, когда будет выполнен метод finish(), и фактическим завершения потока. Было бы замечательно, если бы при получении сигнала извне, метод sleep() возвращал выполнение и поток незамедлительно начинал своё завершение. Для выполнения такого сценария существует встроенное средство оповещения потока, которое называется Interruption (прерывание, вмешательство).</p>
		 <h3>Interruption</h3>
		 <p>Класс Thread содержит в себе скрытое булево поле, подобное полю mFinish в программе Incremenator, которое называется флагом прерывания. Установить этот флаг можно вызвав метод interrupt() потока. Проверить же, установлен ли этот флаг, можно двумя способами. Первый способ — вызвать метод bool isInterrupted() объекта потока, второй — вызвать статический метод bool Thread.interrupted(). Первый метод возвращает состояние флага прерывания и оставляет этот флаг нетронутым. Второй метод возвращает состояние флага и сбрасывает его. Заметьте что Thread.interrupted() — статический метод класса Thread, и его вызов возвращает значение флага прерывания того потока, из которого он был вызван. Поэтому этот метод вызывается только изнутри потока и позволяет потоку проверить своё состояние прерывания.</p>
		 <p>Итак, вернемся к нашей программе. Механизм прерывания позволит нам решить проблему с засыпанием потока. У методов, приостанавливающих выполнение потока, таких как sleep(), wait() и join() есть одна особенность — если во время их выполнения будет вызван метод interrupt() этого потока, они, не дожидаясь конца времени ожидания, сгенерируют исключение InterruptedException.</p>
		 <p>Переделаем программу Incremenator – теперь вместо завершения потока с помощью метода finish() будем использовать стандартный метод interrupt(). А вместо проверки флага mFinish будем вызывать метод bool Thread.interrupted();</p>
		 <p>Так будет выглядеть класс Incremenator после добавления поддержки прерываний:</p>
		 <pre>class Incremenator extends Thread
{
	private volatile boolean mIsIncrement = true;

	public void changeAction()	//Меняет действие на противоположное
	{
		mIsIncrement = !mIsIncrement;
	}

	@Override
	public void run()
	{
		do
		{
			if(!Thread.interrupted())	//Проверка прерывания
			{
				if(mIsIncrement) Program.mValue++;	//Инкремент
				else Program.mValue--;			//Декремент

				//Вывод текущего значения переменной
				System.out.print(Program.mValue + " ");
			}
			else
				return;		//Завершение потока

			try{
				Thread.sleep(1000);		//Приостановка потока на 1 сек.
			}catch(InterruptedException e){
				return;	//Завершение потока после прерывания
			}
		}
		while(true);
	}
}

class Program
{
	//Переменая, которой оперирует инкременатор
	public static int mValue = 0;

	static Incremenator mInc;	//Объект побочного потока

	public static void main(String[] args)
	{
		mInc = new Incremenator();	//Создание потока

		System.out.print("Значение = ");

		mInc.start();	//Запуск потока

		//Троекратное изменение действия инкременатора
		//с интервалом в i*2 секунд
		for(int i = 1; i <= 3; i++)
		{
			try{
				Thread.sleep(i*2*1000);		//Ожидание в течении i*2 сек.
			}catch(InterruptedException e){}

			mInc.changeAction();	//Переключение действия
		}

		mInc.interrupt();	//Прерывание побочного потока
	}
}

Консоль:
Значение = 1 2 1 0 -1 -2 -1 0 1 2 3 4</pre>
		 <p>Как видите, мы избавились от метода finish() и реализовали тот же механизм завершения потока с помощью встроенной системы прерываний. В этой реализации мы получили одно преимущество — метод sleep() вернет управление (сгенерирует исключение) незамедлительно после прерывания потока.</p>
		 <p>Заметьте что методы sleep() и join() обёрнуты в конструкции try-catch. Это необходимое условие работы этих методов. Вызывающий их код должен перехватывать исключение InterruptedException, которое они бросают при прерывании во время ожидания.</p>
		 <p>С запуском и завершением потоков разобрались, дальше я расскажу о методах, использующихся при работе с потоками.</p>
		 <h3>Метод Thread.sleep()</h3>
		 <p>Thread.sleep() — статический метод класса Thread, который приостанавливает выполнение потока, в котором он был вызван. Во время выполнения метода sleep() система перестает выделять потоку процессорное время, распределяя его между другими потоками. Метод sleep() может выполняться либо заданное кол-во времени (миллисекунды или наносекунды) либо до тех пор пока он не будет остановлен прерыванием (в этом случае он сгенерирует исключение InterruptedException).</p>
		 <pre>Thread.sleep(1500); 		//Ждет полторы секунды
Thread.sleep(2000, 100);  	//Ждет 2 секунды и 100 наносекунд</pre>
		 <p>Несмотря на то, что метод sleep() может принимать в качестве времени ожидания наносекунды, не стоит принимать это всерьез. Во многих системах время ожидания все равно округляется до миллисекунд а то и до их десятков.</p>
		 <h3>Метод yield()</h3>
		 <p>Статический метод Thread.yield() заставляет процессор переключиться на обработку других потоков системы. Метод может быть полезным, например, когда поток ожидает наступления какого-либо события и необходимо чтобы проверка его наступления происходила как можно чаще. В этом случае можно поместить проверку события и метод Thread.yield() в цикл:</p>
		 <pre>//Ожидание поступления сообщения
while(!msgQueue.hasMessages())		//Пока в очереди нет сообщений
{
	Thread.yield();		//Передать управление другим потокам
}</pre>
		 <h3>Метод join()</h3>
		 <p>В Java предусмотрен механизм, позволяющий одному потоку ждать завершения выполнения другого. Для этого используется метод join(). Например, чтобы главный поток подождал завершения побочного потока myThready, необходимо выполнить инструкцию myThready.join() в главном потоке. Как только поток myThready завершится, метод join() вернет управление, и главный поток сможет продолжить выполнение.</p>
		 <p>Метод join() имеет перегруженную версию, которая получает в качестве параметра время ожидания. В этом случае join() возвращает управление либо когда завершится ожидаемый поток, либо когда закончится время ожидания. Подобно методу Thread.sleep() метод join может ждать в течение миллисекунд и наносекунд – аргументы те же.</p>
		 <p>С помощью задания времени ожидания потока можно, например, выполнять обновление анимированной картинки пока главный (или любой другой) поток ждёт завершения побочного потока, выполняющего ресурсоёмкие операции:</p>
		 <pre>Thinker brain = new Thinker(); 	//Thinker - потомок класса Thread.
brain.start();		//Начать "обдумывание".

do
{
	mThinkIndicator.refresh();		//mThinkIndicator - анимированная картинка.

	try{
		brain.join(250);				//Подождать окончания мысли четверть секунды.
	}catch(InterruptedException e){}
}
while(brain.isAlive());	//Пока brain думает...

//brain закончил думать (звучат овации).</pre>
		 <p>В этом примере поток brain (мозг) думает над чем-то, и предполагается, что это занимает у него длительное время. Главный поток ждет его четверть секунды и, в случае, если этого времени на раздумье не хватило, обновляет «индикатор раздумий» (некоторая анимированная картинка). В итоге, во время раздумий, пользователь наблюдает на экране индикатор мыслительного процесса, что дает ему знать, что электронные мозги чем то заняты.</p>
		 <h3>Приоритеты потоков</h3>
		 <p>Каждый поток в системе имеет свой приоритет. Приоритет – это некоторое число в объекте потока, более высокое значение которого означает больший приоритет. Система в первую очередь выполняет потоки с большим приоритетом, а потоки с меньшим приоритетом получают процессорное время только тогда, когда их более привилегированные собратья простаивают.</p>
		 <p>Работать с приоритетами потока можно с помощью двух функций:</p>
		 <p><b>void setPriority(int priority)</b> – устанавливает приоритет потока.</p>
		 <p>Возможные значения priority — MIN_PRIORITY, NORM_PRIORITY и MAX_PRIORITY.</p>
		 <p><b>int getPriority()</b> – получает приоритет потока.</p>
		 <h3>Некоторые полезные методы класса Thread</h3>
		 <p>Это практически всё. Напоследок приведу несколько полезных методов работы с потоками.</p>
		 <table border="5">
			 <tr>
				 <td>Функция</td>
				 <td>Значение</td>
			 </tr>
			 <tr>
				 <td><b>boolean isAlive()</b></td>
				 <td>возвращает true если myThready() выполняется и false если поток еще не был запущен или был завершен.</td>
			 </tr>
			 <tr>
				 <td><b>setName(String threadName)</b></td>
				 <td>Задает имя потока.</td>
			 </tr>
			 <tr>
				 <td><b>String getName()</b></td>
				 <td>Получает имя потока.</td>
			 </tr>
			 Имя потока – ассоциированная с ним строка, которая в некоторых случаях помогает понять, какой поток выполняет некоторое действие. Иногда это бывает полезным.
			 <tr>
				 <td><b>static Thread Thread.currentThread()</b></td>
				 <td>статический метод, возвращающий объект потока, в котором он был вызван.</td>
			 </tr>
			 <tr>
				 <td><b>long getId()</b></td>
				 <td>возвращает идентификатор потока. Идентификатор – уникальное число, присвоенное потоку.</td>
			 </tr>
		 </table>
	 </div>
      <!-- gallery end -->


	<!-- footer start -->
    <div class="templatemo_footer">
    	<div class="container">
    	<div class="row">
        	<div class="col-md-9 col-sm-12">
            	<span>MukashevCorp &copy; 2019 OSPU | MOAIS</span>
            </div>
            <div class="col-md-3 col-sm-12 templatemo_rfooter">
            	  <a href="https://vk.com/art_m_m">
                 	<div class="hex_footer">
					<span class="fa fa-facebook"></span>
					</div>
                  </a>
            </div>
        </div>
        </div>
    </div>
    <!-- footer end -->    
	<script>
	$('.gallery_more').click(function(){
		var $this = $(this);
		$this.toggleClass('gallery_more');
		if($this.hasClass('gallery_more')){
			$this.text('Показать больше');
		} else {
			$this.text('Показать меньше');
		}
	});
    </script>
	<!-- templatemo 400 polygon -->
  </body>
</html>