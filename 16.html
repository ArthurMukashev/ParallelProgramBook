<!DOCTYPE html>
  <head>
    <title>Интерактивный учебник</title>
    <meta name="keywords" content="" />
	<meta name="description" content="" />
    <!-- 
    Polygon Template
    https://templatemo.com/tm-400-polygon
    -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- Bootstrap -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="css/templatemo_misc.css">
    <link href="css/templatemo_style.css" rel="stylesheet">
    <link href='http://fonts.googleapis.com/css?family=Raleway:400,100,600' rel='stylesheet' type='text/css'>
      
    <script src="js/jquery-1.10.2.min.js"></script> 
	<script src="js/jquery.lightbox.js"></script>
	<script src="js/templatemo_custom.js"></script>
    <script>
    function showhide()
    {
    	var div = document.getElementById("newpost");
		if (div.style.display !== "none")
		{
			div.style.display = "none";
		}
		else {
			div.style.display = "block";
		}
    }
  	</script>
  </head>
  <body>
  	<div class="site-header">
		<div class="main-navigation">
			<div class="responsive_menu">
				<ul>
					<li><a href="index.html">На главную</a></li>
				</ul>
			</div>
			<div class="container">
				<div class="row templatemo_gallerygap">
					<div class="col-md-12 responsive-menu">
						<a href="#" class="menu-toggle-btn">
				            <i class="fa fa-bars"></i>
				        </a>
					</div> <!-- /.col-md-12 -->
                    <div class="col-md-3 col-sm-12">
                    	<a href="index.html"><img src="images/templatemo_logo.png" alt="Polygon HTML5 Template"></a>
                    </div>
					<div class="col-md-9 main_menu">
						<ul>
							<li><a href="index.html">
                            	<span class="fa fa-book"></span>
                                На главную</a></li>
						</ul>
					</div> <!-- /.col-md-12 -->
				</div> <!-- /.row -->
			</div> <!-- /.container -->
		</div> <!-- /.main-navigation -->
	</div> <!-- /.site-header -->
    <div id="menu-container">
    <!-- gallery start -->
     <div class="container">
		 <h2>16. Автоматическое распараллеливание. OpenMP. Инструментальные средства.</h2>
		 <a class="fa fa-book" href="https://software.intel.com/ru-ru/articles/automatic-parallelization-with-intel-compilers"> Источник 1</a>
		 |
		 <a class="fa fa-book" href="https://keldysh.ru/council/1/bakhtin.htm"> Источник 2</a>
		 |
		 <a class="fa fa-book" href="https://ru.wikipedia.org/wiki/%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D1%80%D0%B0%D1%81%D0%BF%D0%B0%D1%80%D0%B0%D0%BB%D0%BB%D0%B5%D0%BB%D0%B8%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5"> Источник 3</a>

		 <p>Компиляторы Intel® C++ и Fortran могут анализировать данные в циклах и определять, какие циклы имеет смысл выполнять параллельно. Автоматическаяпараллелизация избавляет программиста от необходимости:</p>
		 <ul>
			 <li>Отыскивать циклы, пригодные для параллельного выполнения;</li>
			 <li>Выполнять анализ потока данных для проверки корректности параллельного выполнения;</li>
			 <li>Вручную добавлять параллельные директивы компилятора.</li>
		 </ul>
		 <p>Добавление опций -Qparallel (Windows*) или -parallel (Linux* или Mac OS* X) в команду компилятора – единственное, что требуется от программиста. Однако успешнаяпараллелизация может зависеть еще от некоторых условий, которые описываются в следующей главе.</p>
		 <p>Следующая программа на Фортране содержит цикл с большим количеством итераций:</p>
		 <pre>1 PROGRAM TEST
2 PARAMETER (N=10000000)
3 REAL A, C(N)
4 DO I = 1, N
5 A = 2 * I - 1
6 C(I) = SQRT(A)
7 ENDDO
8 PRINT*, N, C(1), C(N)
9 END</pre>
		 <p>Анализ данных подтверждает, что цикл не содержит зависимостей по данным. Компилятор будет генерировать код, распределяющий итерации равномерно по потокам. Количество потоков по умолчанию равно общему количеству процессорных ядер (что может быть больше, чем количество физических ядер, если включена технология Intel® HyperThreading), но может устанавливаться независимо через переменную окружения OMP_NUM_THREADS. Ускорение при параллельном выполнении данного цикла зависит от количества работы, баланса нагрузки между потоками, величины издержек на создание и синхронизацию потоков и т.д., но в общем плане ускорение будет ниже, чем линейное по отношению к количеству используемых потоков. Для программы в целом ускорение зависит от отношения количества параллельных вычислений к количеству последовательных.</p>
		 <h4>Рекомендации</h4>
		 <p>Чтобы компилятор мог заниматься параллелизацией цикла, должны быть выполнены три условия. Во-первых, количество итераций должно быть известно до начала работы, чтобы её можно было разделить заранее. Цикл while, например, обычно для распараллеливания не подходит. Во-вторых, не должно быть переходов внутрь или наружу цикла. В-третьих, самое важное, итерации цикла должны быть независимыми. Другими словами, корректность результата не должна логически зависеть от порядка выполнения итераций. Здесь, однако, могут быть некоторые вариации при накоплении ошибки округления, как, например, когда некие величины складываются в разном порядке. В ряде случаев, например, при суммировании массива или другом использовании временных скалярных значений, компилятор может убирать очевидную зависимость с помощью простого преобразования.</p>
		 <p>Множественность указателей (aliasing) или элементов массивов – ещё одно часто встречающееся препятствие для безопаснойпараллелизации. Два указателя являются алиасными, если оба указывают на один и тот же участок памяти. Компилятор может не иметь возможности определить, указывают ли два указателя или элемента массива на один и тот же адрес памяти, если они зависят от аргументов функции, динамических данных или результатов сложных вычислений. Если компилятор не может доказать, что указатели или ссылки массива являются защищенными и что итерации независимы, то он не станет параллелить цикл, за исключением тех редких случаев, когда он вынужден генерировать альтернативные пути кода для явного тестирования алиасинга во время запуска. Если программист знает, что параллелизацияконкретного цикла является безопасной и что потенциальными дублированными ссылками можно пренебречь, то этот факт можно сообщить компилятору с помощью прагмы С (#pragmaparallel) или директивы Фортрана (!DIR$ PARALLEL).В С альтернативным способом указать, что указатель нигде не дублируется, является использование оператора restrict при объявлении указателя наряду с использованием опции командной строки -Qrestrict (Windows) или -restrict (Linux или Mac OS* X) . Тем не менее, компилятор никогда не станет параллелить цикл, который доказано является небезопасным.</p>
		 <p>Компилятор может эффективно анализировать циклы только с относительно простой структурой. Например, он не может определить потокобезопасность цикла, содержащего вызовы внешних функций, поскольку он не знает, имеет ли вызов функции какие-нибудь побочные эффекты, которые могут вносить зависимости. Программисты, использующие Fortran 90, могут использовать атрибут PURE для обозначения того, что подпрограммы и функции не имеют побочных эффектов. ВС или Fortran также можно включать межпроцедурную оптимизацию с помощью опции компилятора -Qipo (Windows) или -ipo (Linux или Mac OS X). Это даёт компилятору возможность ставить функции инлайн или анализировать вызываемые функции на предмет наличия побочных эффектов.</p>
		 <p>Когда компилятор не может автоматически распараллелить сложные циклы, про которые программист знает, что их можно безопасно выполнять параллельно, можно с успехом использовать OpenMP. Обычно программист понимает код лучше, чем компилятор, и может выразить параллелизм с большей гранулярностью. С другой стороны, автоматическаяпараллелизация может быть эффективной для вложенных циклов, применяемых, например, при умножении матриц. Среднезернистый параллелизм возникает при параллелизации внешнего цикла, что позволяет оптимизировать внутренние циклы при более мелкозернистом параллелизме с использованием векторизации или программных конвейеров.</p>
		 <p>Тот факт, что цикл может быть распараллелен, не означает, что он должен быть распараллелен. Компилятор использует оценочную модель с пороговым параметром для решения, нужно ли распараллелить цикл. Опции компилятора -Qpar-threshold[n] (Windows) и -par-threshold[n] (Linux) управляют этим параметром. Значение n может меняться от 0 до 100, где 0 означает, что нужно всегда параллелить безопасные циклы, независимо от модели оценки, а 100 говорит компилятору параллелизовать только те циклы, для которых выигрыш в производительности будет достаточной высок. Значение n по умолчанию установлено в консервативные 100. иногда уменьшение порогового значения до 99 может привести к существенному увеличению количества распараллеленных циклов. Прагма #parallelalways (!DIR$ PARALLEL ALWAYS в Fortran) может использоваться для отключения оценочной модели для отдельного цикла.</p>
		 <p>Опции -Qpar-report[n] (Windows) и -par-report[n] (Linux), где n варьируется от 1 до 3, позволяют показывать сообщения о том, какие циклы были распараллелены. Сообщения выглядят примерно так:</p>
		 <pre>test.f90(6) : (col. 0) remark: LOOP WAS AUTO-PARALLELIZED</pre>
		 <p>Компилятор также сообщит, какие циклы не могли быть распараллелены и почему:</p>
		 <pre>1 serial loop: line 6
2 flow data dependence from line 7 to line 8, due to "c"
Подобный эффект наблюдается например здесь:
1 void add (int k, float *a, float *b)
2 {
3 for (int i = 1; i < 10000; i++)
4 a[i] = a[i+k] + b[i];
5 }</pre>
		 <p>Команда компиляции 'icl -c -Qparallel -Qpar-report3 add.cpp' выводит примерно такие сообщения:</p>
		 <pre>1 procedure: add
2 test.c(7): (col. 1) remark: parallel dependence: assumed ANTI dependence between a line 7 and a line 7. flow data dependence assumed
3 ...
4 test.c(7): (col. 1) remark: parallel dependence: assumed FLOW dependence between a line 7 and b line 7.</pre>
		 <p>Поскольку компилятор не знает значение k, он должен предположить, что итерации зависят друг от друга, как, например, если k равняется -1. Однако программист может знать об обратном, так как хорошо знаком с программой (например, что k всегда больше 10000), и может преодолеть мнение компилятора с помощью прагмы:</p>
		 <pre>1 void add (int k, float *a, float *b)
2 {
3 #pragma parallel
4 for (int i = 1; i < 10000; i++)
5 a[i] = a[i+k] + b[i];
6 }</pre>
		 <p>Теперь сообщение говорит, что цикл был распараллелен:</p>
		 <pre>1 procedure: add
2 test.c(6): (col. 1) remark: LOOP WAS AUTO-PARALLELIZED.</pre>
		 <p>Однако программист должен следить за тем, чтобы функция не вызывалась со значением, меньшим 10000.</p>
		 <h4>Указания к применению</h4>
		 <p>Попробуйте собрать ядро приложения, содержащее интенсивные вычисления, применяя опции компилятора -parallel (Linux или Mac OS X) или -Qparallel (Windows). Вывод отчета разрешается с помощью опции -par-report3 (Linux) или -Qpar-report3 (Windows). Из него можно узнать, какие циклы были распараллелены, а какие нет. В последних можно попробовать убрать зависимости по данным и/или помочь компилятору устранить потенциальные повторные ссылки на переменные. Компиляция с опцией -O3 разрешает дополнительную высокоуровневую оптимизацию циклов (такую, как слияние циклов), что иногда может помочь автопараллелизации. Такая дополнительная оптимизация выводится в оптимизационном отчете компилятора при наличии опции -opt-report-phasehlo. . Необходимо всегда измерять производительность с и без параллелизациидля проверки, что необходимое ускорение достигнуто.</p>
		 <p>Если в командной строке указаны обе опции -openmp и -parallel, то компилятор будет пытаться распараллелить только те циклы, в которых не содержится директив OpenMP. Для сборки с разделенными стадиями компилирования и компоновки (link), при использовании автоматической параллелизации необходимо подключить динамическую библиотеку OpenMP. Самый простой способ сделать это – использовать для компоновки драйвер компилятора с помощью, например, опций icl -Qparallel (Windows) или ifort -parallel (Linux или Mac OS X). В системе Mac OS X может понадобиться установить переменную окружения DYLD_LIBRARY_PATH в Xcode, чтобы динамическая библиотека OpenMP могла быть найдена при старте.</p>
	 </div>
      <!-- gallery end -->


	<!-- footer start -->
    <div class="templatemo_footer">
    	<div class="container">
    	<div class="row">
        	<div class="col-md-9 col-sm-12">
            	<span>MukashevCorp &copy; 2019 OSPU | MOAIS</span>
            </div>
            <div class="col-md-3 col-sm-12 templatemo_rfooter">
            	  <a href="https://vk.com/art_m_m">
                 	<div class="hex_footer">
					<span class="fa fa-facebook"></span>
					</div>
                  </a>
            </div>
        </div>
        </div>
    </div>
    <!-- footer end -->    
	<script>
	$('.gallery_more').click(function(){
		var $this = $(this);
		$this.toggleClass('gallery_more');
		if($this.hasClass('gallery_more')){
			$this.text('Показать больше');
		} else {
			$this.text('Показать меньше');
		}
	});
    </script>
	<!-- templatemo 400 polygon -->
  </body>
</html>