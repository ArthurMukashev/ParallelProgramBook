<!DOCTYPE html>
  <head>
    <title>Интерактивный учебник</title>
    <meta name="keywords" content="" />
	<meta name="description" content="" />
    <!-- 
    Polygon Template
    https://templatemo.com/tm-400-polygon
    -->
    <meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=10, user-scalable=yes">
    
    <!-- Bootstrap -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="css/templatemo_misc.css">
    <link href="css/templatemo_style.css" rel="stylesheet">
    <link href='http://fonts.googleapis.com/css?family=Raleway:400,100,600' rel='stylesheet' type='text/css'>
      
    <script src="js/jquery-1.10.2.min.js"></script> 
	<script src="js/jquery.lightbox.js"></script>
	<script src="js/templatemo_custom.js"></script>
    <script>
    function showhide()
    {
    	var div = document.getElementById("newpost");
		if (div.style.display !== "none")
		{
			div.style.display = "none";
		}
		else {
			div.style.display = "block";
		}
    }
  	</script>
  </head>
  <body>
  	<div class="site-header">
		<div class="main-navigation">
			<div class="responsive_menu">
				<ul>
					<li><a href="index.html">На главную</a></li>
				</ul>
			</div>
			<div class="container">
				<div class="row templatemo_gallerygap">
					<div class="col-md-12 responsive-menu">
						<a href="#" class="menu-toggle-btn">
				            <i class="fa fa-bars"></i>
				        </a>
					</div> <!-- /.col-md-12 -->
                    <div class="col-md-3 col-sm-12">
                    	<a href="index.html"><img src="images/templatemo_logo.png" alt="Polygon HTML5 Template"></a>
                    </div>
					<div class="col-md-9 main_menu">
						<ul>
							<li><a href="index.html">
                            	<span class="fa fa-book"></span>
                                На главную</a></li>
						</ul>
					</div> <!-- /.col-md-12 -->
				</div> <!-- /.row -->
			</div> <!-- /.container -->
		</div> <!-- /.main-navigation -->
	</div> <!-- /.site-header -->
    <div id="menu-container">
    <!-- gallery start -->
     <div class="container">
		 <h2>7. Семафор</h2>
		 <a class="fa fa-book" href="https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D0%BC%D0%B0%D1%84%D0%BE%D1%80_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)"> Источник 1</a>
		 |
		 <a class="fa fa-book" href="https://habr.com/ru/post/261273/"> Источник 2</a>
		 |
		 <a class="fa fa-book" href="https://ru.bmstu.wiki/%D0%A1%D0%B5%D0%BC%D0%B0%D1%84%D0%BE%D1%80_(%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5_%D0%A1%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B)"> Источник 3</a>

		 <p><b>Семафор</b> (англ. semaphore) — примитив синхронизации  работы процессов и потоков, в основе которого лежит счётчик, над которым можно производить две атомарные операции: увеличение и уменьшение значения на единицу, при этом операция уменьшения для нулевого значения счётчика является блокирующейся. Служит для построения более сложных механизмов синхронизации и используется для синхронизации параллельно работающих задач, для защиты передачи данных через разделяемую память, для защиты критических секций, а также для управления доступом к аппаратному обеспечению.</p>
		 <p><b>Легковесный семафор</b> — механизм, позволяющий в ряде случаев уменьшить количество системных вызовов за счёт использования активного цикла ожидания в течение некоторого времени перед выполнением блокировки.</p>
		 <p>Семафоры могут быть двоичными и вычислительными. <b>Вычислительные семафоры</b> могут принимать целочисленные неотрицательные значения и используются для работы с ресурсами, количество которых ограничено, либо участвуют в синхронизации параллельно исполняемых задач. <b>Двоичные семафоры</b> являются частным случаем вычислительного семафора и могут принимать только два значения: 0 и 1.</p>
		 <p><b>Мьютексные семафоры</b> или мьютексы — упрощённая реализация семафоров, аналогичная двоичным семафорам с тем отличием, что мьютексы должны отпускаться тем же процессом или потоком, который осуществляет их захват. Наряду с двоичными семафорами используются в организации критических участков кода. В отличие от двоичных семафоров, начальное состояние мьютекса не может быть захваченным и они могут поддерживать наследование приоритетов.</p>
		 <h2>Общие сведения</h2>
		 <p>Понятие семафора было введено в 1965 году нидерландским учёным Эдсгером Дейкстрой, а в 1968 году он предложил использовать два семафора для решения задачи производителя и потребителя.</p>
		 <p>Семафор представляет собой счётчик, над которым можно выполнять две операции: увеличение на 1 (англ. up) и уменьшение на 1 (англ. down). При попытке уменьшения семафора, значение которого равно нулю, задача, запросившая данное действие, должна блокироваться до тех пор, пока не станет возможным уменьшение значения семафора до неотрицательного значения, то есть пока другой процесс не увеличит значение семафора. Под блокированием задачи понимается изменение состояния процесса или потока планировщиком задач на такое, при котором задача приостановит своё исполнение].</p>
		 <p>Операции уменьшения и увеличения значения семафора первоначально обозначались буквами P (от нидерл. proberen — пытаться) и V (от нидерл. verhogen — поднимать выше) соответственно. Данные обозначения дал операциям над семафорами Дейкстра, но так как они не понятны для людей, говорящих на других языках, на практике обычно используются другие обозначения. Обозначения up и down впервые начали использоваться в языке Алгол 68.</p>
		 <p>Операции увеличения и уменьшения значения семафора вместе со всеми проверками должны быть атомарными. Если в момент увеличения значения семафора есть более одного заблокированного по данному семафору процесса, то операционная система выбирает один из них и разрешает ему закончить операцию уменьшения значения семафора.</p>
		 <p>Принято считать, что значение семафора является неотрицательным, но существует и другой подход к определению семафора, при котором под отрицательным значением понимается количество заблокированных задач с отрицательным знаком. При таком подходе уменьшение семафора является блокирующимся, если результат операции стал отрицательным.</p>
		 <p>Основным назначением семафора является разрешение или временный запрет на выполнение каких-либо действий, поэтому если значение счётчика семафора больше нуля, то говорят, что он находится в сигнальном состоянии, если же значение равно нулю — в несигнальном состоянии. Уменьшение значения семафора также иногда называют захватом (англ. acquire), а увеличение значения — отпусканием или освобождением (англ. release), что позволяет сделать описание работы семафора более понятным в контексте контроля использования какого-либо ресурса или при использовании в критических секциях.</p>
		 <p>В общем виде семафор можно представить как объект, состоящий из:</p>
		 <ul>
			 <li>переменной-счётчика, хранящей текущее значение семафора;</li>
			 <li>списка заблокированных в ожидании сигнального значения семафора задач;</li>
			 <li>функций атомарного увеличения и уменьшения значения семафора.</li>
		 </ul>
		 <p>Концепция семафора хорошо подходит для синхронизации потоков, может использоваться для синхронизации процессов, однако совершенно не подходит для синхронизации взаимодействия компьютеров. Семафор является низкоуровневым примитивом синхронизации, поэтому, за исключением защиты критических секций, сам по себе может быть сложен в использовании.</p>
		 <p>Другим, более низкоуровневым, примитивом синхронизации является фьютекс. Он может предоставляться операционной системой и хорошо подходит для реализации семафоров на прикладном уровне при использовании атомарных операций над разделяемым счётчиком.</p>
		 <h2>Алгоритмы использования</h2>
		 <h3>Типовые алгоритмы</h3>
		 <h4>Сигнализированные</h4>
		 <p>Сигнализирование, также называемое уведомлением, является базовым назначением семафоров, оно гарантирует исполнение участка кода одной задачи после исполнения участка кода другой задачи. Сигнальное использование семафора обычно предполагает установку его начального значения в 0, чтобы ожидающие сигнального состояния задачи могли блокироваться до наступления события. Сигнализирование выполняется через увеличение значения семафора, а ожидание — через уменьшение значения.</p>
		 <h3>Пример сигнализирования семафором</h3>
		 <h3>Основной поток</h3>
		 <ul>
			 <li>Инициализировать семафор <b>А</b> (А ← 0)</li>
			 <table>
				 <tr>
					 <td><b>Поток 1</b></td>
					 <td><b>Поток 2</b></td>
				 </tr>
				 <tr>
					 <td>
						 <li><i>Выполнить подготовку ресурса</i></li>
						 <li>Сигнализировать семафором <b>А</b> (А ← 1)</li>
						 <hr>
						 <i>Разблокировка потока 2</i>
						 <li><i>Действия над общим ресурсом</i></li>
					 </td>
					 <td>
						 <i>Поток 2 первым получил процессорное время</i>
						 <li>Ожидать сигнального состояния <b>А</b> (блокировка)</li>
						 <hr>
						 <i>Разблокировка А ← 0</i>
						 <li><i>Действия над общим ресурсом</i></li>
					 </td>
				 </tr>
			 </table>
			 <hr>
		 </ul>
		 <p>Семафоры хорошо подходят для сигнализирования одной или нескольким задачам, количество которых заранее известно. Если количество ожидающих сигнального состояния задач заранее неизвестно, то обычно используются условные переменные.</p>
		 <h4>Взаимное исключение</h4>
		 <p>В многопоточных приложениях часто требуется, чтобы отдельные участки кода, называемые критическими секциями, не могли работать параллельно, например, при доступе к какому-либо неразделяемому ресурсу или при изменении общих ячеек памяти. Для защиты таких участков можно использовать двоичный семафор или мьютекс. Мьютекс является более безопасным в использовании, поскольку может быть отпущен только тем процессом или потоком, который его захватил. Также использование мьютекса вместо семафора может быть более производительным за счёт оптимизации под два значения на уровне реализации ассемблерного кода.</p>
		 <p>Начальным значением семафора выставляется единица, означая, что он не захвачен — в критическую секцию пока никто не вошёл. Входом (англ. enter) в критическую секцию является захват семафора — его значение уменьшается до 0, что делает повторную попытку входа в критическую секцию блокирующейся. При выходе (англ. leave) из критической секции семафор отпускается, и его значения становится равным 1, разрешая снова входить в критическую секцию, в том числе и другим потокам или процесса.</p>
		 <p>Для разных ресурсов могут быть разные семафоры, отвечающие за критические секции. Таким образом, критические секции, защищённые разными семафорами, могут работать параллельно.</p>
		 <h3>Пример работы критической секции на основе семафора</h3>
		 <h3>Основной поток</h3>
		 <ul>
			 <li>Инициализировать семафор <b>А</b> (А ← 0)</li>
			 <table>
				 <tr>
					 <td><b>Поток 1</b></td>
					 <td><b>Поток 2</b></td>
				 </tr>
				 <tr>
					 <td>
						 <i>Поток 1 первым получил процессорное время</i>
						 <hr>
						 <li>Захватить семафор <b>А</b> (А ← 0)</li>
						 <li><i>Выполнить действия над ресурсом</i></li>
						 <li>Отпустить семафор <b>А</b> (А ← 1)</li>
						 <hr>
						 <i>Разблокировка потока 2</i>
					 </td>
					 <td>
						 <i>А захвачен в потоке 1</i>
						 <hr>
						 <li>Захватить семафор <b>А</b> (блокировка)</li>
						 <hr>
						 <i>Разблокировка, А ← 0</i>
						 <li><i>Выполнить действия над ресурсом</i></li>
						 <li>Отпустить семафор <b>А</b> (А ← 1)</li>
					 </td>
				 </tr>
			 </table>
		 </ul>
			 <p>Помимо семафоров, взаимное исключение может быть организовано и через другие способы синхронизации, например, через мониторы, если они поддерживаются используемым языком программирования. Мониторы позволяют защитить набор данных, скрывая от программиста детали синхронизации и предоставляя доступ к защищаемым данных только процедурам монитора. По сравнению с семафорами мониторы позволяют уменьшить количество ошибок в программах, но несмотря на удобство использования, количество языков с поддержкой мониторов — небольшое.</p>
		 <h4>Турникет</h4>
		 <p>Частой бывает задача разрешения или запрета для одной или более задач прохождения через определённые контрольные точки. Для решения данной задачи используется алгоритм на основе двух семафоров, который по своей работе напоминает турникет, поскольку позволяет единовременно пропускать только одну задачу. Турникет основывается на семафоре, который в контрольных точках захватывается и сразу же освобождается. Если требуется закрыть турникет, то семафор необходимо захватить, в результате чего все задачи, проходящие через турникет будут блокироваться. Если требуется снова разрешить задачам проходить через турникет, что достаточно отпустить семафор, после чего задачи будут по очереди продолжать исполнение.</p>
		 <p>У поочерёдного прохождения через турникет есть большой недостаток — на каждое прохождение может происходить лишнее переключение контекста между задачами, в результате чего будет снижаться производительность алгоритма. В некоторых случаях решением может быть использование многоместного турникета, который разблокирует сразу несколько задач, что может осуществляться, например, циклическим отпусканием семафора, если используемая реализация семафора не поддерживает увеличение на произвольное число.</p>
		 <h4>Выключатель</h4>
		 <p>Ещё одним типовым алгоритмом на основе семафоров является реализация выключателя. Задачи могут захватывать выключатель и освобождать его. Первая задача, которая захватывает выключатель, включает его. А последняя задача, которая его освобождает, — выключает. Для данного алгоритма можно провести аналогию с выключателем света в комнате. Первый, кто входит в комнату, — включает свет, а последний, кто выходит, — выключает.</p>
		 <p>Алгоритм может реализовываться на основе счётчика захвативших выключатель задач и семафора выключателя, операции над которыми должны защищаться мьютексом. При захвате выключателя счётчик увеличивается на 1, а если его значение изменилось с нуля на один, то семафор выключателя захватывается, что равносильно включению выключателя. При этом увеличение счётчика вместе с проверкой и захватом семафора являются атомарной операцией, защищаемой мьютексом. При отпускании выключателя счётчик уменьшается, а если его значения стало нулевым, то семафор выключателя отпускается, то есть выключатель переводится в выключенное состояние. Уменьшение счётчика вместе с его проверкой и отпусканием семафора тоже должны быть атомарной операцией.</p>
		 <h4>Задача производителя и потребителя</h4>
		 <p>Задача производителя потребителя предполагает производство какой-либо информации одной задачей и передачу этой информации другой задаче для обработки. В многопоточных системах одновременное производство и потребление может приводить к состоянию гонки, что требует использования критических секций или других способов синхронизации. Семафор является наиболее простым примитивом синхронизации, с помощью которого можно решать задачу производителя и потребителя.</p>
		 <h4>Передача данных через кольцевой буфер</h4>
		 <p>Кольцевой буфер представляет собой буфер с фиксированным количеством элементов, данные в который заносятся и обрабатываются в порядке очереди (FIFO). В однопоточном варианте исполнения для организации такого буфера достаточно 4-х ячеек памяти:</p>
		 <ul>
			 <li>общее количество элементов в буфере,</li>
			 <li>количество занятых или количество свободных элементов в буфере,</li>
			 <li>порядковый номер текущего элемента,</li>
			 <li>порядковый номер следующего элементов.</li>
		 </ul>
		 <p>В многозадачной реализации алгоритм усложняется необходимостью синхронизации задач. Для случая двух задач (производитель и потребитель) можно ограничиться двумя ячейками памяти и двумя семафорами:</p>
		 <ul>
			 <li>индекс следующего элемента, доступного на чтение,</li>
			 <li>индекс следующего элемента, доступного на запись,</li>
			 <li>семафор, разрешающий чтение очередного элемента,</li>
			 <li>семафор, разрешающий запись очередного свободного элемента буфера.</li>
		 </ul>
		 <p>Начальное значение семафора, отвечающего за чтение, устанавливается в 0, потому что очередь пуста. А значение семафора, отвечающего за запись, выставляется равным общему размеру буфера, то есть весь буфер доступен для заполнения. Перед заполнением очередного элемента в буфере семафор на запись уменьшается на 1, резервируя очередной элемент очереди для записи данных, после чего изменяется индекс на запись, а семафор на чтение увеличивается на 1, разрешая чтение добавленного в очередь элемента. Читающая задача, наоборот, захватывает семафор на чтение, после чего считывает очередной элемент из буфера и изменяет индекс следующего элемента на чтение, а затем отпускает семафор на запись, разрешая запись пишущей задаче в освободившийся элемент.</p>
		 <p>Если кольцевой буфер реализуется для множества пишущих и читающих задач, то к реализации добавляется мьютекс, который блокирует буфер при записи в него или чтении из него.</p>
		 <h4>Передача данных через произвольный буфер</h4>
		 <p>Помимо передачи данных через кольцевой буфер, возможна передача и через произвольный, но в таком случае запись и чтение данных требуется защищать мьютексом, а семафор используется для оповещения читающей задачи о наличии очередного элемента в буфере. Пишущая задача добавляет в буфер элемент под защитой мьютекса, а затем сигнализирует о его наличии. Читающая же задача захватывает семафор, а затем, под защитой мьютекса, — получает очередной элемент. Стоит упомянуть, что попытка захвата семафора под защитой мьютекса может приводить к взаимоблокировке в случае попытки чтения из пустого буфера, а отпускание семафора внутри критической секции может слегка снизить производительность. Данный алгоритм, как и в случае с кольцевым буфером, защищённым мьютексом, позволяет писать и читать одновременно нескольким задачам.</p>
		 <h3>В механизмах синхронизации</h3>
		 <h4>Барьер</h4>
		 <p>Барьер представляет собой механизм синхронизации критических точек у группы задач. Задачи могут пройти через барьер только все сразу. Перед входом в критические точки задачи группы должны блокироваться, пока входа в критическую точку не достигнет последняя задача из группы. Как только все задачи окажутся перед входом в свои критические точки, они должны продолжить своё исполнение.</p>
		 <p>Самое простое решение для организации барьера в случае двух задач основывается на двух бинарных семафорах А и Б, инициализируемых нулевым значением. В критической точке первой задачи необходимо перевести в сигнальное состояние семафор Б, а затем захватить семафор А. В критической точке второй задачи необходимо сначала перевести в сигнальное состояние семафор А, а затем — захватить Б. Какая бы задача не дошла до критической точки первой, она просигнализирует другой задаче, разрешив её исполнение. Как только обе задачи достигнут своих критических точек, их семафоры окажутся в сигнальном состоянии, что позволит им продолжить своё исполнение.</p>
		 <p>Подобная реализация — однопроходная, поскольку барьер не возвращается в исходное состояние, также у неё низкая производительность из-за использования одноместного турникета, что требует переключения контекста для каждой задачи, поэтому на практике данное решение малоприменимо.</p>
		 <h4>Двухфазный барьер</h4>
		 <p>Особенностью двухфазного барьера является то, что при его использовании каждая задача останавливается на барьере дважды — до критической точки и после. Два останова позволяют сделать барьер реентерабельным, поскольку второй останов позволяет вернуть барьер в изначальное состояние.</p>
		 <p>Универсальный реентерабельный алгоритм механизма двухфазного барьера может быть основан на использовании счётчика дошедших до критической точки задач и двух многоместных турникетов. Операции над счётчиком и управление турникетами должны быть защищены мьютексом. При этом должно быть заранее известно общее количество задач. Первый турникет пропускает задачи к критической точке и изначально должен быть заблокирован. Второй — пропускает задачи, которые только что прошли критическую точку, и изначально тоже должен быть заблокирован. Перед подходом к критической точке счётчик дошедших задач увеличивается на 1, а как только он достигает общего количества задач, то первый турникет разблокируется для всех задач, пропуская их к критической точке, что происходит атомарно через мьютекс вместе с увеличением счётчика и его проверкой. После критической точки, но до второго турникета, счётчик количества задач уменьшается на 1. По достижении нулевого значения второй турникет разблокируется для всех задач, при этом операции над вторым турникетом тоже происходят атомарно вместе с уменьшением счётчика и его проверкой. В результате все задачи останавливаются сначала перед критической точкой, а затем — после. После прохождения барьера состояния счётчика и турникетов оказываются в изначальных значениях.</p>
		 <h4>Условная переменная</h4>
		 <p>Условная переменная представляет собой способ оповещения ожидающих задач о возникновении какого-либо события. Механизм условной переменной на прикладном уровне обычно строится на основе фьютекса и предусматривает функции ожидания события и отправки сигнала о его возникновении, но отдельные части этих функций должны защищаться мьютексом или семафором, поскольку помимо фьютекса в механизме условной переменной обычно присутствуют дополнительные разделяемые данные. В простых реализациях фьютекс можно заменить семафором, который при оповещении необходимо будет отпустить столько раз, сколько задач подписалось на условную переменную, однако при большом количестве подписчиков оповещение может стать узким местом.</p>
		 <p>Механизм условной переменной предполагает наличие трёх операций: ожидание события, сигнализирование о событии одной задаче и оповещение всех задач о событии. Для реализации алгоритма на основе семафоров потребуются: мьютекс или двоичный семафор для защиты, собственно, самой условной переменной, счётчик количества ожидающих задач, мьютекс для защиты счётчика, семафор А для блокировки ожидающих задач и дополнительный семафор Б для своевременного пробуждения очередной ожидающей задачи.</p>
		 <p>При подписке на события счётчик подписавшихся задач атомарно увеличивается на 1, после чего отпускается предварительно захваченный мьютекс условной переменной. Затем захватывается семафор А для ожидания наступления события. По наступлению события сигнализирующая задача атомарно проверяет счётчик подписавшихся задач и оповещает очередную задачу о наступлении события, отпуская семафор А, а затем блокируется по семафору Б в ожидании подтверждения разблокировки. Получившая оповещение задача отпускает семафор Б и снова захватывает мьютекс условной переменной для возврата в изначальное состояние. Если же делается широковещательное оповещение всех подписанных задач, то семафор заблокированных задач А отпускается в цикле по количеству подписанных задач в счётчике. При этом оповещение происходит атомарно под защитой мьютекса счётчика, чтобы счётчик не мог измениться во время оповещения.</p>
		 <p>У решения на семафорах есть одна значимая проблема — два переключения контекста по сигнализированию, что сильно снижает производительность алгоритма, поэтому как минимум на уровне операционных систем оно обычно не применяется.</p>
		 <p>Интересным фактом является то, что сам семафор легко реализуется на основе условной переменной и мьютекса, а реализация условной переменной на основе семафоров — намного сложнее.</p>
		 <h4>Блокировки чтения и записи</h4>
		 <p>Одной из классических проблем является синхронизация доступа к ресурсу, доступному одновременно на чтение и на запись. Блокировки чтения и записи русск. призваны решить эту проблему и позволяют организовать раздельную блокировку ресурса на чтение и на запись, разрешая одновременное чтение, но запрещая одновременную запись. Запись также блокирует любое чтение. Эффективный механизм может быть построен на базе фьютекса, однако блокировки чтения и записи могут быть также реализованы на основе комбинации мьютексов и семафоров или мьютексов и условной переменной.</p>
		 <p>Самым простым алгоритмом реализации на семафорах и мьютексах является использование выключателя бинарного семафора. Запись должна защищаться данным семафором. Первая читающая задача должна захватывать семафор с помощью выключателя, блокируя пишущие потоки, а последняя заканчивающая свою работы — должна отпускать семафор, разрешая пишущим задачам продолжить свою работу. Однако данная реализация имеет одну серьёзную проблему, сравнимую с взаимной блокировкой, — ресурсное голодание пишущих задач.</p>
		 <p>Универсальный алгоритм, лишённый описанной выше проблемы, включает в себя выключатель бинарного семафора А для организации критической секции читающих задач и турникет для блокировки новых читающих задач при наличии ожидающих пишущих. При появлении первой читающей задачи она захватывает семафор А с помощью выключателя, запрещая запись. Для пишущих задач семафор А защищает критическую секцию записи, поэтому, если он захвачен читающими задачами, все пишущие задачи блокируются при входе в свою критическую секцию. Однако захват пишущими задачами семафора А с последующей записью защищается семафором турникета. Поэтому, если произошла блокировка пишущей задачи из-за наличия читающих, турникет блокируется вместе с новыми читающими задачами. Как только последняя читающая заканчивает свою работу, семафор выключателя отпускается, и первая в очереди пишущая задача разблокируется. По окончании своей работы она отпускает семафор турникета, снова разрешая работу читающих задач.</p>
		 <p>На уровне операционных систем существуют реализации семафоров чтения и записи, которые специальным образом модифицируются для повышения эффективности при массовом использовании.</p>
		 <h3>В классических задачах</h3>
		 <h4>Обедающие философы</h4>
		 <p>Одной из классических задач синхронизации является задача об обедающих философах. Задача включает в себя 5 обедающих за круглым столом философов, 5 тарелок, 5 вилок и общее блюдо с макаронами посреди стола. Перед каждым философом есть тарелка, а справа и слева — по одной вилке, но каждая вилка является общей между двумя соседними философами, а есть макароны можно только двумя вилками одновременно. При этом каждый из философов может или думать, или есть макароны.</p>
		 <p>Философами представлены взаимодействующие в программе потоки, а решение задачи включает в себя ряд условий</p>
		 <ul>
			 <li>между философами не должно быть взаимоблокировок;</li>
			 <li>ни один философ не должен голодать, ожидая освобождение вилки;</li>
			 <li>должно быть возможным, чтобы одновременно ели хотя бы два философа.</li>
		 </ul>
		 <p>Для решения задачи каждой вилке можно назначить двоичный семафор. Когда философ пытается взять вилку, семафор захватывается, а как только он заканчивает есть, семафоры вилок отпускаются. Проблема заключается в том, что вилку уже мог взять сосед, тогда философ блокируется до тех пор, пока его сосед не поест. Если одновременно все философы начнут приём пищи, то возможна взаимоблокировка.</p>
		 <p>Решением взаимоблокировки может быть ограничение количества одновременно обедающих философов до 4-х. В таком случае по крайней мере один философ сможет обедать, пока остальные ожидают. Ограничение можно реализовать через семафор с начальным значением 4. Каждый из философов будет захватывать данный семафор перед тем как взять вилки, а после приёма пищи — отпускать. Также данное решение гарантирует отсутствие голодания у философов, поскольку, если философ ожидает освобождения вилки соседом, тот рано или поздно её отпустит.</p>
		 <p>Существует и более простое решение. Взаимоблокировка возможна, если одновременно 5 философов держат вилку в одной и той же руке, например, если они все правши и вначале взяли правую вилку. Если же один из философов является левшой и берёт вначале левую вилку, то невозможны ни взаимоблокировка, ни голодание. Таким образом, достаточно, чтобы у одного из философов сначала захватывался семафор левой вилки, а затем — правой, в то время как у остальных философов — наоборот.</p>
		 <h4>Американские горки</h4>
		 <p>Другой классической задачей является задача об американских горках, согласно которой состав вагонеток полностью заполняется пассажирами, затем катает их по кругу и возвращается назад за новыми. По условиям задачи количество желающих пассажиров превышает количество мест в составе, таким образом, очередные пассажиры ожидают своей очереди, пока состав едет по кругу. Если состав имеет М мест, то сначала состав должен ожидать, пока на свои места не сядут М пассажиров, затем он должен прокатить их, подождать, пока они все выйдут и снова ожидать новых пассажиров.</p>
		 <p>Состав вагонеток вместе с пассажирами можно представить как взаимодействующие задачи. Каждый пассажир должен блокироваться в ожидании своей очереди, а сам состав должен блокироваться на этапах заполнения и освобождения мест. Для загрузки и выгрузки состава можно воспользоваться двумя семафорами с выключателями, защищёнными каждый своим мьютексом, а для блокирования пассажиров на загрузку и на выгрузку можно использовать два семафора, отвечающие за места в вагонетках. Ожидающие пассажиры захватывают семафор на загрузку, а состав семафором на загрузку оповещает M из них о наличии свободных мест. Затем состав блокируется по выключателю, пока последний усаживающийся пассажир не просигнализирует соответствующим семафором, после чего начинается поездка. Перед поездкой пассажиры блокируются по семафору на выгрузку, что не даёт им выйти из состава. После поездки состав оповещает M пассажиров семафором на выгрузку, разрешая им выйти, а затем блокируется по семафору выключателя на выгрузку, ожидая, пока все пассажиры не выйдут. Как только последний пассажир выйдет из состава, он просигнализирует семафором второго выключателя и разрешит составу снова набирать пассажиров.</p>
		 <h2>Проблемы использования</h2>
		 <h4>Ограничения семафоров</h4>
		 <p>Концепция семафора предусматривает лишь операции уменьшения и увеличения на 1. При этом задача, уменьшающая семафор, обычно не может узнать, будет ли она заблокирована по нему или нет. При сигнализировании же нет возможности узнать, есть ли заблокированные по семафору задачи, а если задача сигнализирует семафором другой, заблокированной, — то обе задачи продолжают работать параллельно и нет никакой возможности узнать, какая из них получит процессорное время следующей.</p>
		 <p>Несмотря на ограничения концепции семафоров, конкретные их реализации могут быть лишены тех или иных ограничений. Например, возможность увеличения значения семафора на произвольное число предусмотрена в реализациях Linux, Windows и System V (POSIX). А семафоры POSIX позволяют определить, будет ли блокировка по захвату семафора.</p>
		 <h4>Сильные и слабые семафоры</h4>
		 <p>Помимо ограничений самой концепции семафора, существуют и ограничения, накладываемые операционной системой или конкретной реализацией семафора. За распределение процессорного времени между процессами и потоками обычно отвечает планировщик задач операционной системы. Использование семафоров предъявляет ряд требований к планировщику и самой реализации семафоров для предотвращения ресурсного голодания, которое недопустимо в многозадачных приложениях.</p>
		 <ol>
			 <li>Если есть хотя бы одна задача, готовая к исполнению, она должна исполняться.</li>
			 <li>Если задача готова к исполнению, время до начала её исполнения должно быть конечным.</li>
			 <li>Если происходит сигнализирование семафором, по которому есть заблокированные задачи, то, по крайней мере, одна из них должна перейти в состояние готовности к исполнению.</li>
			 <li>Если задача заблокирована по семафору, то количество других задач, которые будут разблокированы по тому же семафору до заданной, должно быть конечным.</li>
		 </ol>
		 <p>Первые два требования необходимы, чтобы любая задача могла получить процессорное время и не находилась бесконечно в состоянии готовности, что уже позволяет писать приложения без ресурсного голодания. Третье требование необходимо для предотвращения ресурсного голодания при взаимном исключении, построенном на семафорах. Если сигнализирование будет лишь увеличивать счётчик семафора, но не будет пробуждать заблокированную по нему задачу, то возможна ситуация, когда одна и та же задача бесконечно отпускает и захватывает семафор, а другие заблокированные задачи не успевают перейти в состояние готовности, либо переходят, но гораздо реже. Однако даже при соблюдении третьего требования в случае большого количества заблокированных задач возможно ресурсное голодание, если каждый раз разблокируются одни и те же задачи. Данную проблему решает четвёртое требование, которое соблюдается, например, если заблокированные по семафору задачи пробуждаются в порядке очереди.</p>
		 <p>Соблюдение первых трёх требований позволяет реализовать так называемые <b>слабые семафоры</b>, а соблюдение всех четырёх — <b>сильные</b>.</p>
		 <h4>Взаимные блокировки</h4>
		 <p>При неправильном использовании семафоров могут возникать взаимные блокировки — ситуации, когда две или более параллельных задач оказываются заблокированными, ожидая отпускания блокировки друг от друга. В такой ситуации задачи не смогут нормально продолжить своё исполнение и обычно один или более процессов требуется завершить принудительно. Взаимные блокировки могут быть как результатом простых ошибок работы с семафорами или другими способами синхронизации, так и вследствие состояния гонки, которое является более сложным в отладке.</p>
		 <p>Типовой ошибкой является вызов внутри критической секции подпрограммы, использующей ту же самую критическую секцию.</p>
		 <p>Наглядным примером взаимной блокировки могут служить вложенные друг в друга захваты бинарных семафоров А и Б, защищающих разные ресурсы, при условии обратного порядка их захвата в одном из потоков, что может быть обусловлено, например, стилевыми отличиями в написании кода программы. Ошибкой подобной реализации является состояние гонки, из-за которого программа может работать большую часть времени, но в случае параллельного захвата ресурсов высоки шансы на взаимную блокировку.</p>
		 <h3>Пример взаимной блокировки с обратной вложенностью критических секций</h3>
		 <h3>Основной поток</h3>
		 <ul>
			 <li>Инициализировать семафор <b>А</b> (А ← 1)</li>
			 <li>Инициализировать семафор <b>Б</b> (Б ← 1)</li>
			 <table>
				 <tr>
					 <td><b>Поток 1</b></td>
					 <td><b>Поток 2</b></td>
				 </tr>
				 <tr>
					 <td>
						 <i>Поток 1 первым получил процессорное время</i>
						 <hr>
						 <li>Захватить семафор <b>А</b> (А ← 0)</li>
						 <hr>
						 <i>Б захвачен в потоке 2</i>
						 <li>Захватить семафор <b>Б</b> (блокировка)</li>
						 <li><i>Выполнить действия над ресурсом</i></li>
						 <li>Отпустить семафор <b>Б</b></li>
						 <li>Отпустить семафор <b>А</b></li>
					 </td>
					 <td>
						 <li>Захватить семафор <b>Б</b> (Б ← 0)</li>
						 <hr>
						 <i>А захвачен в потоке 1</i>
						 <li>Захватить семафор <b>А</b> (блокировка)</li>
						 <li><i>Выполнить действия над ресурсом</i></li>
						 <li>Отпустить семафор <b>А</b></li>
						 <li>Отпустить семафор <b>Б</b></li>
					 </td>
				 </tr>
			 </table>
		 </ul>
		 <h4>Ресурсное голодание</h4>
		 <p>Схожей с взаимной блокировкой является проблема ресурсного голодания, которая может и не приводить к полному прекращению работы, но может оказаться крайне негативной при реализации алгоритма. Суть проблемы заключается в периодических или частых отказах в получении ресурса из-за его захвата другими задачами.</p>
		 <p>Типичным случаем для данной проблемы является простая реализация блокировок чтения и записи, при которой происходит запрет ресурса на запись при осуществлении чтения. Периодическое появление новых читающих задач может привести к неограниченной блокировке ресурса на запись. При слабой нагрузке на систему проблема может не проявляться длительное время, однако при высокой нагрузке может возникнуть ситуация, когда в каждый момент времени есть по крайней мере одна читающая задача, что сделает блокировку на запись постоянной на время высокой нагрузки. При наличии семафора, отпускаемого при опустении очереди читающих задач, простым решением может быть добавление двоичного семафора (или мьютекса) для защиты кода пишущих задач, который в то же время будет выступать в роли турникета для читающих задач. Пишущие задачи будут входить в критическую секцию и захватывать семафор пустой очереди, блокируясь по двум семафорам, пока есть читающие задачи. Читающие задачи будут блокироваться при входе в турникет, если пишущая задача ожидает окончания работы читающих. Как только последняя читающая задача закончит свою работу, она отпустит семафор пустой очереди, разблокировав ожидающую пишущую задачу.</p>
		 <p>Также ресурсному голоданию может быть подвержено даже взаимное исключение, если его реализация будет основана на слабых семафорах, однако существуют алгоритмы, позволяющие обходить ограничения слабых семафоров в данном случае.</p>
		 <h4>Инверсия приоритетов</h4>
		 <p>Другой проблемой может быть инверсия приоритетов, которая может проявиться при использовании семафоров процессами реального времени. Процессы реального времени могут быть прерваны операционной системой только для исполнения процессов с бо́льшим приоритетом. В этом случае процесс может заблокироваться по семафору в ожидании его отпускания процессом с меньшим приоритетом. Если в это время будет работать процесс со средним между двумя процессами приоритетом, то процесс с высоким приоритетом может оказаться заблокированным на неограниченный промежуток времени.</p>
		 <p>Проблема инверсии приоритетов решается наследованием приоритетов. По возможности семафоры могут быть заменены на мьютексы, поскольку у мьютексов наследование приоритетов может быть заранее предусмотрено. Таким образом, при захвате мьютекса потоком с бо́льшим приоритетом произойдёт упреждающее повышение приоритета у задачи, владеющей мьютексом, для его скорейшего отпускания.</p>
		 <p>Повсеместное наследование приоритетов является крайне сложной в реализации задачей, поэтому поддерживающие её системы могут иметь лишь частичную реализацию. Также наследование приоритетов создаёт другие проблемы, например, к невозможности совмещения кода с наследованием приоритетов с кодом без наследования при использовании одной и той же критической секции.</p>
		 <p>При необходимости использования семафоров или при отсутствии поддержки наследования приоритетов алгоритмы могут модифицироваться для самостоятельного повышения приоритетов задачами.</p>
		 <h2>Прикладное программирование</h2>
		 <h4>Семафоры в POSIX</h4>
		 <p>Стандарты POSIX на уровне операционных систем предоставляют API языка Си для работы с семафорами как на уровне потоков, так и на уровне процессов через разделяемую память. Стандарты определяют тип данных семафора sem_t и набор функций для работы с ним. Семафоры POSIX доступны в Linux, macOS, FreeBSD и других POSIX-совместимых операционных системах.</p>
		 <table>
			 <tr>
				 Функции для работы с семафорами POSIX из заголовочного файла semaphore.h
			 </tr>
			 <tr>
				 <td>Функция</td>
				 <td>Описание</td>
			 </tr>
			 <tr>
				 <td>sem_init()</td>
				 <td>sem_init()	Инициализация семафора с заданием начального значения счётчика и флага использования на уровне процессов</td>
			 </tr>
			 <tr>
				 <td>sem_destroy()</td>
				 <td>Освобождение семафора</td>
			 </tr>
			 <tr>
				 <td>sem_open()</td>
				 <td>Создание нового или открытие существующего именованного семафора</td>
			 </tr>
			 <tr>
				 <td>sem_close()</td>
				 <td>Закрытие семафора после окончания работы с ним</td>
			 </tr>
			 <tr>
				 <td>sem_unlink()</td>
				 <td>Удаление имени у именованного семафора (не уничтожает его)</td>
			 </tr>
			 <tr>
				 <td>sem_wait()</td>
				 <td>Уменьшение значения семафора на 1</td>
			 </tr>
			 <tr>
				 <td>sem_timedwait()</td>
				 <td>Уменьшение значения семафора на 1 с ограничением максимального времени блокировки, по истечении которого возвращается ошибка</td>
			 </tr>
			 <tr>
				 <td>sem_trywait()</td>
				 <td>Попытка уменьшения значения семафора в неблокирующемся режиме, возвращает ошибку, если уменьшение без блокировки невозможно</td>
			 </tr>
			 <tr>
				 <td>sem_post()</td>
				 <td>Увеличение значения семафора на 1</td>
			 </tr>
			 <tr>
				 <td>sem_getvalue()</td>
				 <td>Получение текущего значения семафора</td>
			 </tr>
		 </table>
		 <p>Одним из недостатков семафоров POSIX является способствующая ошибкам спецификация функции sem_timedwait(), которая оперирует часами реального времени (CLOCK_REALTIME) вместо времени непрерывной работы системы (CLOCK_MONOTONIC), что может приводить к сбоям в работе программ при изменении системного времени и может оказаться критичным для встраиваемых устройств, но некоторые операционные системы реального времени предлагают аналоги данной функции, работающие с временем непрерывной работы системы. Другим недостатком является отсутствие поддержки ожидания одновременно нескольких семафоров или семафора и файлового дескриптора.</p>
		 <p>В Linux семафоры POSIX реализованы в библиотеке Glibc на основе фьютекса.</p>
		 <h4>Семафоры System V</h4>
		 <p>Стандарты POSIX также определяют набор функций из стандарта X/Open System Interfaces (XSI) для межпроцессовой работы с семафорами в рамках операционной системы. В отличие от обычных семафоров семафоры XSI можно увеличивать и уменьшать на произвольное число, они выделяются массивами, и их время жизни распространяется не на процессы, а на операционную систему. Таким образом, если забыть закрыть семафор XSI по завершению всех процессов приложения, то он продолжит существовать в операционной системе, что называется утечкой ресурса. В сравнении с семафорами XSI обычные семафоры POSIX намного проще в использовании, и у них может быть выше быстродействие.</p>
		 <p>Наборы семафоров XSI в рамках системы идентифицируются по числовому ключу типа key_t, однако можно создавать анонимные наборы семафоров для использования в рамках приложения, если указывать константу IPC_PRIVATE вместо числового ключа.</p>
		 <table>
			 <tr>Функции для работы с семафорами XSI из заголовочного файла sys/sem.h</tr>
			 <tr>
				 <td><b>Функция</b></td>
				 <td><b>Описание</b></td>
			 </tr>
			 <tr>
				 <td>semget()</td>
				 <td>Создаёт или получает идентификатор набора семафоров с заданным числовым ключом</td>
			 </tr>
			 <tr>
				 <td>semop()</td>
				 <td>Выполняет атомарные операции уменьшения и увеличения на заданное число счётчика семафора по его номеру из набора с заданным идентификатором, а также позволяет заблокироваться в ожидании нулевого значения счётчика семафора, если в качестве заданного числа указан 0</td>
			 </tr>
			 <tr>
				 <td>semctl()</td>
				 <td>Позволяет управлять семафором по его номеру из набора с заданным идентификатором, в том числе получать и устанавливать текущее значение счётчика; также отвечает за уничтожение набора семафоров</td>
			 </tr>
		 </table>
		 <h4>Семафоры в Linux</h4>
		 <p>Операционные системы семейства Linux поддерживают семафоры POSIX, но также предлагают альтернативу семафорам в виде счётчика, привязанного к файловому дескриптору через системный вызов eventfd() с флагом EFD_SEMAPHORE. При чтении такого счётчика через функцию read() он уменьшается на 1, если его значение было ненулевым. Если же значение было нулевым, то происходит блокировка (если не указан флаг EFD_NONBLOCK), как и в случае с обычными семафорами. Функция write() увеличивает значение счётчика на число, которое записывается по файловому дескриптору. Преимуществом такого семафора является возможность ожидания сигнального состояния семафора наряду с другими событиями с помощью системных вызовов select() или poll().</p>
		 <h4>Семафоры в Windows</h4>
		 <p>Ядро Windows также предоставляет API языка Си для работы с семафорами. Потоки, заблокированные по семафору, выстраиваются в очередь FIFO, но могут перейти в конец очереди в случае прерывания потока для обработки других событий.</p>
		 <table>
			 <tr>Основные функции для работы с семафорами Windows API</tr>
			 <tr>
				 <td><b>Функция</b></td>
				 <td><b>Описание</b></td>
			 </tr>
			 <tr>
				 <td>CreateSemaphoreA()</td>
				 <td>Создание семафора с указанием начального значения счётчика, максимального значения и имени семафора</td>
			 </tr>
			 <tr>
				 <td>OpenSemaphoreW()</td>
				 <td>Получение доступа к семафору по его имени, если он уже существует</td>
			 </tr>
			 <tr>
				 <td>CloseHandle()</td>
				 <td>Закрытие семафора после окончания работы с ним</td>
			 </tr>
			 <tr>
				 <td>WaitForSingleObject() или WaitForMultipleObjects()</td>
				 <td>Уменьшение значения семафора на 1 с блокировкой в случае нулевого значения счётчика; позволяет ограничивать максимальное время блокировки</td>
			 </tr>
			 <tr>
				 <td>ReleaseSemaphore()</td>
				 <td>Увеличение значения семафора на указанную величину</td>
			 </tr>
		 </table>
		 <p>Особенностями семафоров под Windows является возможность увеличивать семафор на произвольное число и возможность ожидания его сигнального состояния вместе с блокирующим ожиданием других семафоров или объектов.</p>
		 <h4>Поддержка в языках программирования</h4>
		 <p>Семафоры обычно не поддерживаются на уровне языка программирования в явном виде, но часто предоставляются встроенными или сторонними библиотеками. В некоторых языках, таких как Ada и Go, семафоры легко реализуются средствами языка.</p>
		 <table>
			 <tr>
				 Семафоры в распространённых языках программирования
			 </tr>
			 <tr>
				 <td>Язык</td>
				 <td>Модуль или библиотека</td>
				 <td>Тип данных</td>
			 </tr>
			 <tr>
				 <td>Си</td>
				 <td>pthread, rt</td>
				 <td>sem_t</td>
			 </tr>
			 <tr>
				 <td>Ada</td>
				 <td>GNAT.Semaphores</td>
				 <td>Counting_Semaphore, Binary_Semaphore</td>
			 </tr>
			 <tr>
				 <td>C++</td>
				 <td>Boost</td>
				 <td>boost::interprocess::interprocess_semaphore</td>
			 </tr>
			 <tr>
				 <td>C#</td>
				 <td>System.Threading</td>
				 <td>Semaphore</td>
			 </tr>
			 <tr>
				 <td>D</td>
				 <td>core.sync.semaphore</td>
				 <td>Semaphore</td>
			 </tr> <tr>
			 <td>Go</td>
			 <td>golang.org/x/sync/semaphore</td>
			 <td>Weighted</td>
		 </tr> <tr>
			 <td>Java</td>
			 <td>java.util.concurrent</td>
			 <td>java.util.concurrent.Semaphore</td>
		 </tr> <tr>
			 <td>Python</td>
			 <td>asyncio</td>
			 <td>asyncio.Semaphore</td>
		 </tr>
		 </table>
		 <h2>Примеры использования</h2>
		 <h4>Защита критической секции</h4>
		 <p>Самым простым примером использования семафора может служить взаимное исключение возможности исполнения критических участков кода у потоков или процессов. Для организации взаимного исключения может служить двоичный семафор и две функции: входа в критическую секцию и выхода из неё. Для упрощения в пример не включена возможность запоминания идентификатора захватившего потока и идентификатора процесса, которому поток принадлежит. Также предполагается, что критическая секция имеет конечное не очень большое время исполнения, поэтому прерывания операции захвата семафора (EINTR) игнорируются, а обработку результатов прерывания можно осуществлять после критической секции. Сам семафор проабстрагирован в структуру для повышения читабельности кода.</p>
		 <p>В примере запускаются два потока, один из которых увеличивает счётчик, а другой — уменьшает. Поскольку счётчик является разделяемым ресурсом, доступ к нему должен быть взаимоисключающим, в противном случае один поток может перезаписывать результаты операций другого, а итоговое результирующее значение может оказаться ошибочным. Поэтому счётчик защищается проабстрагированным двоичным семафором, реализующим взаимное исключение.</p>
		 <h2>Детали реализации</h2>
		 <h4>В операционных системах</h4>
		 <p>В общем виде операционные системы осуществляют атомарные операции чтения и записи значения счётчика семафора, но детали реализации могут различаться на разных архитектурах. При захвате семафора операционная система должна атомарно уменьшить значение счётчика, после чего процесс может продолжить свою работу. Если же в результате уменьшения счётчика значение может стать отрицательным, то операционная система должна приостановить выполнение процесса до тех пор, пока значение счётчика не станет таким, чтобы операция уменьшения привела к неотрицательному результату. При этом в зависимости от архитектуры на уровне реализации может быть выполнена как попытка уменьшения значения семафора так и его уменьшение с получением отрицательного результата. На уровне прикладного интерфейса обычно условно считается, что минимальным значением семафора является 0. При увеличении значения семафора, по которому были заблокированы процессы, происходит разблокировка очередного процесса, а значение семафора на прикладном уровне остаётся равным нулю.</p>
		 <p>Блокировка на уровне операционной системы обычно не предполагает физического ожидания на процессоре, а передаёт управление процессором другой задаче, в то время как ожидающая отпускания семафора — попадает в очередь заблокированных по данному семафору задач. В случае же, если количество готовых к исполнению задач меньше количества процессоров, ядро операционной системы может перевести свободные процессоры в режим экономии энергопотребления до наступления каких-либо событий.</p>
		 <h2>На уровне процессоров</h2>
		 <h4>В архитектурах x86 и x86_64</h4>
		 <p>Для синхронизации работы процессоров в многопроцессорных системах существуют специальные инструкции, позволяющие защитить доступ к какой-либо ячейке. В архитектуру x86 компанией Intel для ряда инструкций процессора предусмотрен префикс LOCK, позволяющий выполнять атомарные операции над ячейками памяти. Операции над ячейкой, выполняемые с префиксом LOCK, блокируют доступ остальных процессоров к ячейке, что на примитивном уровне позволяет организовывать легковесные семафоры с активным циклом ожидания.</p>
		 <p>Атомарное уменьшение значения семафора на 1 может быть выполнено при помощи инструкции DECL с префиксом LOCK, которая выставляет флаг знака CS в случае, если результирующее значение оказывается меньше нуля. Особенностью такого подхода является то, что значение семафора может оказываться меньше нуля, поэтому после уменьшения счётчика флаг CS может проверяться с помощью инструкции JNS, и, если знак отрицательный, то операционная система может заблокировать текущую задачу.</p>
		 <p>Для атомарного увеличения значения семафора на 1 может использоваться инструкция LOCK INCL. Если результирующее значение оказывается отрицательным либо равным нулю, то это означает наличие ожидающих задач, в таком случае операционная система может разблокировать очередную задачу. Для пропуска разблокировки процессов может использоваться инструкция JG, которая осуществляет переход к метке, если флаги нулевого результата операции (ZF) и знака результата (SF) сброшены в 0, то есть если значение больше 0.</p>
		 <p>Во время блокировки в случаях отсутствия текущих задач может использоваться инструкция HLT, предназначенная для перевода процессора в режим низкого энергопотребления с ожиданием прерываний, которые необходимо предварительно разрешать с помощью инструкции STI. Однако в современных процессорах более оптимальным может быть использование инструкций MWAIT и MONITOR. Инструкция MWAIT аналогична HLT, но позволяет пробудить процессор по записи в ячейку памяти по адресу, указанному в MONITOR. NWAIT можно использовать для мониторинга изменения ячейки семафора, однако в многозадачных операционных системах эта инструкция используется для мониторинга флага необходимости запустить планировщик задач на заданном ядре.</p>
		 <p>Снижение энергопотребления во время активного цикла ожидания может достигаться с помощью инструкции PAUSE.</p>
		 <h4>В архитектуре ARM</h4>
		 <p>В архитектуре ARMv7 для синхронизации памяти используются так называемые локальный и глобальный эксклюзивные мониторы, представляющие собой автоматы состояний, контролирующие атомарный доступ к ячейкам памяти. Атомарное чтение ячейки памяти может осуществляться с помощью инструкции LDREX, а атомарная запись — через инструкцию STREX, которая также возвращает флаг успеха операции.</p>
		 <p>Для уменьшения значения семафора необходимо дождаться, пока его счётчик не станет больше нуля. Ожидание может быть реализовано разными способами:</p>
		 <ul>
			 <li>цикл активного ожидания в случае легковесного семафора, при котором периодически считывается значение счётчика с помощью инструкции LDREX;</li>
			 <li>блокировка с переводом процессора в энергосберегающий режим ожидания с помощью инструкций ожидания прерывания WFI или ожидания события WFE;</li>
			 <li>переключение контекста на исполнение другой задачи вместо блокировки процессора.</li>
		 </ul>
		 <p>На уровне многозадачной операционной системы может использоваться комбинация перечисленных способов для обеспечения максимальной загрузки процессоров с переходом в энергосберегающий режим во время простоев.</p>
		 <p>Увеличение значения семафора может представлять собой циклическое чтение текущего значения счётчика через инструкцию LDREX с последующим увеличением копии значения и попыткой записи обратно в ячейку счётчика с помощью инструкции STREX. При этом чтение может не являться цикличным в случае бинарного семафора, поскольку его увеличение всегда будет приводить к записи в счётчик одного и того же значения, а сама запись не обязана быть синхронизируемой. После успешной записи счётчика, если его изначальное значение было нулевым, требуется возобновить исполнение заблокированных задач, что в случае переключения контекста может решаться средствами операционных систем. Если процессор был заблокирован с помощью инструкции WFE, разблокировать его можно через инструкцию SEV, оповещающей о наличии какого-либо события. Также эта команда может использоваться для разблокировки процессора, если не используется переключение контекста.</p>
		 <p>После уменьшения или увеличения значения семафора выполняется инструкция DMB, обеспечивающую гарантию целостности памяти защищаемого семафором ресурса.</p>
	 </div>
      <!-- gallery end -->


	<!-- footer start -->
    <div class="templatemo_footer">
    	<div class="container">
    	<div class="row">
        	<div class="col-md-9 col-sm-12">
            	<span>MukashevCorp &copy; 2019 OSPU | MOAIS</span>
            </div>
            <div class="col-md-3 col-sm-12 templatemo_rfooter">
            	  <a href="https://vk.com/art_m_m">
                 	<div class="hex_footer">
					<span class="fa fa-facebook"></span>
					</div>
                  </a>
            </div>
        </div>
        </div>
    </div>
    <!-- footer end -->    
	<script>
	$('.gallery_more').click(function(){
		var $this = $(this);
		$this.toggleClass('gallery_more');
		if($this.hasClass('gallery_more')){
			$this.text('Показать больше');
		} else {
			$this.text('Показать меньше');
		}
	});
    </script>
	<!-- templatemo 400 polygon -->
  </body>
</html>