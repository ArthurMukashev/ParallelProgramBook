<!DOCTYPE html>
  <head>
    <title>Интерактивный учебник</title>
    <meta name="keywords" content="" />
	<meta name="description" content="" />
    <!-- 
    Polygon Template
    https://templatemo.com/tm-400-polygon
    -->
    <meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=10, user-scalable=yes">
    
    <!-- Bootstrap -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="css/templatemo_misc.css">
    <link href="css/templatemo_style.css" rel="stylesheet">
    <link href='http://fonts.googleapis.com/css?family=Raleway:400,100,600' rel='stylesheet' type='text/css'>
      
    <script src="js/jquery-1.10.2.min.js"></script> 
	<script src="js/jquery.lightbox.js"></script>
	<script src="js/templatemo_custom.js"></script>
    <script>
    function showhide()
    {
    	var div = document.getElementById("newpost");
		if (div.style.display !== "none")
		{
			div.style.display = "none";
		}
		else {
			div.style.display = "block";
		}
    }
  	</script>
  </head>
  <body>
  	<div class="site-header">
		<div class="main-navigation">
			<div class="responsive_menu">
				<ul>
					<li><a href="index.html">На главную</a></li>
				</ul>
			</div>
			<div class="container">
				<div class="row templatemo_gallerygap">
					<div class="col-md-12 responsive-menu">
						<a href="#" class="menu-toggle-btn">
				            <i class="fa fa-bars"></i>
				        </a>
					</div> <!-- /.col-md-12 -->
                    <div class="col-md-3 col-sm-12">
                    	<a href="index.html"><img src="images/templatemo_logo.png" alt="Polygon HTML5 Template"></a>
                    </div>
					<div class="col-md-9 main_menu">
						<ul>
							<li><a href="index.html">
                            	<span class="fa fa-book"></span>
                                На главную</a></li>
						</ul>
					</div> <!-- /.col-md-12 -->
				</div> <!-- /.row -->
			</div> <!-- /.container -->
		</div> <!-- /.main-navigation -->
	</div> <!-- /.site-header -->
    <div id="menu-container">
    <!-- gallery start -->
     <div class="container">
		 <h2>4. Процессы. Потоки. Виды синхронизации. Свойства параллельных программ</h2>
		 <a class="fa fa-book" href="https://docplayer.ru/41311130-Parallelnoe-vypolnenie-processov-i-potokov-sinhronizaciya.html"> Источник 1</a>
		 |
		 <a class="fa fa-book" href="http://window.edu.ru/resource/974/67974/files/de_synchron.pdf"> Источник 2</a>
		 |
		 <a class="fa fa-book" href="https://studfile.net/preview/5282731/page:4/"> Источник 3</a>

		 <p>
			 Процесс — программа, которая выполняется в текущий момент. Стандарт ISO 9000:2000 определяет процесс как совокупность взаимосвязанных и взаимодействующих действий, преобразующих входящие данные в исходящие.		 </p>
		 <p>
			 Компьютерная программа сама по себе — лишь пассивная последовательность инструкций. В то время как процесс — непосредственное выполнение этих инструкций.
	 	 </p>
		 <p>
			 Также, процессом называют выполняющуюся программу и все её элементы: адресное пространство, глобальные переменные, регистры, стек, открытые файлы и так далее.
		 <p>
			 Обычно, процесс в вычислительной системе представлен (также говорят, «владеет») следующими ресурсами:
	     </p>
		 <ul>
			 <li>образом исполняемого машинного кода, ассоциированного с программой;</li>
			 <li>
				 памятью (обычно некоторой областью виртуальной памяти), которая включает в себя:
				 <ul>
					 <li>исполняемый код;</li>
					 <li>входные и выходные данные процесса;</li>
					 <li>стек вызовов (для отслеживания активных подпрограмм);</li>
					 <li>кучу для хранения промежуточных результатов вычислений, генерируемых во время выполнения;</li>
				 </ul>
			 </li>
			 <li>дескрипторами ресурсов операционной системы, выделенными для процесса, например, файл</li>
			 <li>файловыми дескрипторами (в терминологии ОС Unix) или «хэндлами» (в терминологии ОС Windows);</li>
		 	 <li>атрибутами безопасности, такими как владелец и набор полномочий процесса (допустимых операций);</li>
			 <li>
				 состоянием процессора (контекстом), таким как:
			 	<ul>
					<li>содержимое регистров;</li>
					<li>схема преобразования виртуальных адресов в физические...</li>
				</ul>
			 </li>
		 </ul>
		 <p>Контекст текущего процесса выгружается в память, когда выполняется переключение на другой процесс.</p>
		 <p>Операционная система хранит большую часть информации о процессах в таблице процессов.</p>
		 <p>В операционных системах, поддерживающих потоки выполнения (нити), потоки также владеют собственными ресурсами. Обычно это только состояние процессора, хотя потоки могут использовать и другие ресурсы.</p>
		 <p>Для снижения вероятности влияния процессов друг на друга и вероятности отказа системы (например, взаимных блокировок или пробуксовки) операционная система обеспечивает изоляцию процессов и выделяет необходимые им ресурсы. Также операционная система предоставляет механизмы для взаимодействия процессов безопасными и предсказуемыми способами.</p>
		 <p style="text-align: center;"><img src="img/41.png"><br>Рис. 4.1. Завершение процесса</p>
		 <p>Минимум 2 этапа завершения:</p>
		 <ol>
			 <li>Процесс удаляется из всех очередей планирования, то есть ОС больше не планирует выделение каких-либо ресурсов процессу.</li>
			 <li>Сбор статистики о потреблённых процессом ресурсах с последующим удалением его из памяти.</li>
		 </ol>
		 <p>Причины завершения процесса:</p>
		 <ul>
			 <li>Обычный выход,</li>
			 <li>Выход по исключению или ошибке,</li>
			 <li>Недостаточный объём памяти,</li>
			 <li>Превышение лимита отведённого программе времени,</li>
			 <li>Выход за пределы отведённой области памяти,</li>
			 <li>Неверная команда (данные программы интерпретируются как инструкции для процессора),</li>
			 <li>Ошибка защиты (выполнение непривилегированной команды),</li>
			 <li>Завершение родительского процесса,</li>
			 <li>Ошибка ввода-вывода,</li>
			 <li>Вмешательство оператора.</li>
		 </ul>
		 <h2>Что такое поток?</h2>
		 <p>Поток — это по сути последовательность инструкций, которые выполняются параллельно с другими потоками. Каждая программа создает по меньшей мере один поток: основной, который запускает функцию main (). Программа, использующая только главный поток, является однопоточной; если добавить один или более потоков, она станет многопоточной.</p>
		 <p>Потоки — это способ сделать несколько вещей одновременно. Это может быть полезно, например, для отображения анимации и обработки пользовательского ввода данных во время загрузки изображений или звуков. Потоки также широко используется в сетевом программировании, во время ожидания получения данные будет продолжаться обновление и рисование приложения.</p>
		 <h2>Потоки SFML или std::thread?</h2>
		 <p>В своей последней версии (2011), стандартная библиотека C++ предоставляет набор классов для работы с потоками. Во время написания SFML, стандарт C++11 еще не был написан и не было никакого стандартного способа создания потоков. Когда SFML 2.0 был выпущен, было много компиляторов, которые не поддерживали этот новый стандарт.</p>
		 <p>Если вы работаете с компилятором, который поддерживает новый стандарт и содержит заголовочный файл, забудьте о классах потоков SFML и используйте стандартные классы C++ вместо них. Но, если вы работаете с компилятором, не поддерживающим данный стандарт, или планируете распространять ваш код и хотите добиться полной портируемости, потоковые классы SFML являются хорошим выбором.</p>
		 <h2>Создание потоков с помощью SFML</h2>
		 <p>Давайте посмотрим на код. Класс, дающий возможность создавать потоки с помощью SFML, называется sf::Thread, и вот как это (создание потока) выглядит в действии:</p>
		 <pre style="font-size: 16px;">
#include &#60SFML/System.hpp&#62
#include &#60iostream&#62

void func()
{
//эта функция запускается, когда вызывается thread.launch()
for (int i = 0; i &#60 10; i++)
std::cout&laquo"I'm thread number one"&laquo std::endl;
}

int main()
{
//создание потока с функцией func в качестве точки входа
sf::Thread thread(&func);
//запуск потока
thread.launch();
//главный поток продолжает быть запущенным...
for (int i = 0; i &#60 10; i++)
std::cout&laquo"I'm the main thread"&laquo std::endl;
return 0;
}		 </pre><hr>
		 <p>В этом коде функции main и func выполняются параллельно после вызова thread.launch(). Результатом этого является то, что текст, выводимый обеими функциями, смешивается в консоли.</p>
		 <p style="text-align: center;"><img src="img/42.png" width="100%"><br>Рис. 4.2. Результат</p>
		 <p>Точка входа в поток, т.е. функция, которая будет выполняться, когда поток запускается, должна быть передана конструктору sf::Thread. sf::Thread пытается быть гибким и принимать различные точки входа: non-member функции или методы классов, функции с аргументами или без них, функторы и так далее. Приведенный выше пример показывает, как использовать функцию-член, вот несколько других примеров.</p>
		 <hr>
		 <pre style="font-size: 16px;">
//non-member функция с одним аргументом:
void func(int x)
{
}
sf::Thread thread(&func, 5);
//метод класса:
class MyClass
{
public:
void func()
{}};

MyClass object;
sf::Thread thread(&MyClass::func, &object);
//функтор (функциональный объект):
struct MyFunctor
{
void operator()
{}
};
sf::Thread thread(MyFunctor());</pre><hr>
		 <p>Последний пример, который использует функтор, является наиболее мощным, поскольку он может принимать любые типы функторов и поэтому делает класс sf::Thread совместимым со многими типами функций, которые напрямую не поддерживаются. Эта функция особенно интересна с лямбда-выражениями C++ или std::bind.</p>
		<hr>
		 <pre style="font-size: 16px;">
//с лямбда-функцией
sf::Thread thread([](){
std::cout&laquo "I am in thread!" &laquo std::endl;
});
// cstd::bind
void func(std::string, int, double)
{
}
sf:Thread thread(std::bind(&func, "hello", 24, 0.5));</pre><hr>
		 <p>Если вы хотите использовать sf::Thread внутри класса, не забудьте, что он не имеет стандартного конструктора. Поэтому, вы должны инициализировать его в конструкторе вашего класса в списке инициализации.</p>
		 <h2>Запуск потока</h2>
		 <p>После того, как вы создали экземпляр sf::Thread, вы должны запустить его с помощью запуска функции.</p>
		 <hr>
		 <pre style="font-size: 16px;">
sf::Thread thread(&func);
thread.launch();</pre>
		 <hr>
		 <p>launch вызывает функцию, которую вы передали вконструктор нового потока, и сразу же завершает свою работу, так что вызывающий поток может сразу же продолжить выполнение.</p>
	 	 <h2>Остановка потоков</h2>
		 <p>Поток автоматически завершает свою работу, когда функция, служащая точкой входа для данного потока, возвращает свое значение. Если вы хотите ждать завершения потока из другого потока, вы можете вызвать его функцию wait.</p>
		 <hr>
		 <pre style="font-size: 16px;">
sf::Thread thread(&func);

// запускпотока
thread.launch();

...

// выполнение блокируется до тех пор, пока поток не завершится
thread.wait();</pre><hr>
		 <p>Функция ожидания также неявно вызывается деструктором sf::Thread, так что поток не может оставаться запущенным (и бесконтрольным) после того, как его экземпляр sf::Thread уничтожается. Помните это, когда вы управляете вашими потоками.</p>
		 <h2>Приостановка потока</h2>
		 <p>В SFML нет функции, которая бы предоставляла способ приостановки потока; единственный способ приостановки потока — сделать это из кода самого потока. Другими словами, вы можете только приостановить текущий поток. Что бы это сделать, вы можете вызвать функцию sf::sleep:</p>
		 <hr>
		 <pre style="font-size: 16px;">
void func()
{
    ...
sf::sleep(sf::milliseconds(10));
...
}		 </pre><hr>
		 <p>sf::sleep имеет один аргумент — время приостановки. Это время может быть выражено в любой единице, как было показано в статье про обработку времени.</p>
		 <p>Обратите внимание, что вы можете приостановить любой поток с помощью данной функции, даже главный поток.</p>
		 <p>sf::sleep является наиболее эффективным способом приостановить поток: на протяжении приостановки потока, он (поток) практически не потребляет ресурсы процессора. Приостановка, основанная на активном ожидании, вроде пустого цикла while, потребляет 100% ресурсов центрального процессора и делает… ничего. Однако имейте в виду, что продолжительность приостановки является просто подсказкой; реальная продолжительность приостановки (больше или меньше указанного вами времени) зависит от ОС. Так что не полагайтесь на эту функцию при очень точном отсчете времени.</p>
		 <h2>Защита разделяемых данных</h2>
		 <p>Все потоки в программе разделяют некоторую память, они имеют доступ ко всем переменным в области их видимости. Это очень удобно, но также опасно: с момента параллельного запуска потока, переменные или функции могут использоваться одновременно разными потоками. Если операция не является потокобезопасной, это может привести к неопределенному поведению (т. е. это может привести к сбою или повреждению данных).</p>
		 <p>Существует несколько программных инструментов, которые могут помочь вам защитить разделяемые данные и сделать ваш код потокобезопасным, их называют примитивами синхронизации. Наиболее распространенными являются следующие примитивы: мьютексы, семафоры, условные переменные и спин-блокировки. Все они — варианты одной и той же концепции: они защищают кусок кода, давая только определенному потоку право получать доступ к данным и блокируя остальные.</p>
		 <p>Наиболее распространенным (и используемым) примитивом является мьютекс. Мьютекс расшифровывается как «Взаимное исключение». Это гарантия, что только один поток может выполнять код. Посмотрим, как мьютексы работают, на примере ниже:</p>
		 <hr>
		 <pre style="font-size: 16px;">
#include &#60SFML/System.hpp>
#include &#60iostream>

sf::Mutexmutex;

void func()
{
mutex.lock();

for (int i = 0; i < 10; ++i)
std::cout&laquo "I'm thread number one" &laquo std::endl;

mutex.unlock();
}

int main()
{
sf::Thread thread(&func);
thread.launch();

mutex.lock();

for (int i = 0; i < 10; ++i)
std::cout<< "I'm the main thread" &laquo std::endl;

mutex.unlock();

return 0;
}		 </pre><hr>
		 <p>Этот код использует общий ресурс (std::cout), и, как мы видим, это приводит к нежелательным результатам. Вывод потоков смешался в консоли. Чтобы убедиться в том, что вывод правильно напечатается, вместо того, чтобы быть беспорядочно смешанным, мы защищаем соответствующие области кода мьютексом.</p>
		 <p>Первый поток, который достигает вызова mutex.lock(), блокирует мьютекс и получает доступ к коду, который печатает текст. Когда другие потоки достигают вызова mutex.lock(), мьютекс уже заблокирован, и другие потоки приостанавливают свое выполнение (это похоже на вызов sf::sleep, спящий поток не потребляет время центрального процессора). Когда первый поток разблокирует мьютекс, второй поток продолжает свое выполнение, блокирует мьютекс и печатает текст. Это приводит к тому, что текст в консоли печатается последовательно и не смешивается.</p>
		 <p style="text-align: center;"><img src="img/43.png" width="100%"><br>Рис. 4.3. Результат</p>
		 <p>Мьютекс — это не только примитив, который вы можете использовать для защиты разделяемых данных, вы можете использовать его во многих других случаях. Однако, если ваше приложение делает сложные вещи при работе с потоками, и вы чувствуете, что возможностей мьютексов недостаточно — не стесняйтесь искать другую библиотеку, обладающую большим функционалом.</p>
		 <h2>Защита мьютексов</h2>
		 <p>Не волнуйтесь: мьютексы уже потокобезопасны, нет необходимости их защищать. Но они не безопасны в плане исключений. Что происходит, если исключение выбрасывается, когда мьютекс заблокирован? Он никогда не может быть разблокирован и будет оставаться заблокированным вечно. Все потоки, пытающиеся разблокировать заблокированный мьютекс, будут заблокированы навсегда. В некоторых случаях, ваше приложение будет «заморожено».</p>
		 <p>Чтобы быть уверенным, что мьютекс всегда разблокирован в среде, в которой он (мьютекс) может выбросить исключение, SFML предоставляет RAII класс, позволяющий обернуть мьютекс в класс sf::Lock. Блокировка происходит в конструкторе, разблокировка происходит в деструкторе. Просто и эффективно.</p>
		 <hr>
		 <pre style="font-size: 16px;">
sf::Mutex mutex;

void func()
{
sf::Lock lock(mutex); // mutex.lock()

functionThatMightThrowAnException(); // mutex.unlock(), если функция выбросит исключение

} // mutex.unlock()</pre><hr>
		 <p>Помните, что sf::Lock может также быть использован в функциях, которые имеют множество возвращаемых значений.</p>
		 <pre style="font-size: 16px;">
sf::Mutexmutex;

bool func()
{
sf::Lock lock(mutex); // mutex.lock()

if (!image1.loadFromFile("..."))
return false; // mutex.unlock()

if (!image2.loadFromFile("..."))
return false; // mutex.unlock()

if (!image3.loadFromFile("..."))
return false; // mutex.unlock()

return true;
} // mutex.unlock()</pre><hr>
		 <h2>Распространенные заблуждения</h2>
		 <p>Вещь, часто упускаемая из виду: поток не может существовать без соответствующего экземпляра sf::Thread. Следующий код можно часто увидеть на форумах:</p>
		 <hr>
		 <pre style="font-size: 16px;">
void startThread()
{
sf::Thread thread(&funcToRunInThread);
thread.launch();
}

int main()
{
startThread();
// ...
return 0;
}		 </pre>
		 <hr>
		 <p>Программисты, которые пишут подобный код, ожидают, что функция startThread() будет запускать поток, который будет жить самостоятельно и уничтожаться при завершении выполнения функции (переданной в качестве точки входа). Этого не происходит. Функция потока блокирует главный поток, как если бы программа не работала.</p>
		 <p>В чем дело? Экземпляр sf::Thread является локальным для функции startThread(), поэтому немедленно уничтожаются, когда функция возвращает свое значение. Вызывается деструктор sf::Thread, происходит вызов wait(), как утверждалось выше, результатом этого становится блокировка главного потока, который ожидает завершения функции потока, вместо параллельного выполнения с ней.</p>
		 <p>Так что не забывайте: вы должны управлять экземплярами sf::Thread, чтобы они жили так долго, как требуется функции потока.</p>
		 <p><b>Синхронизация</b> в информатике обозначает одно из: синхронизацию процессов, либо синхронизацию данных, либо процесс синхронизации передачи данных.</p>
		 <p><b>Синхронизация процессов</b> — это механизм, позволяющий обеспечить целостность какого-либо ресурса (файл, данные в памяти), когда он используется несколькими процессами или потоками в случайном порядке. Для синхронизации процессов и потоков используются семафоры, мьютексы и критические секции. Альтернативой синхронизации может служить модель акторов или транзакционная память.</p>
		 <p><b>Синхронизация данных </b>- ликвидация различий между двумя копиями данных. Предполагается, что ранее эти копии были одинаковы, а затем одна из них, либо обе были независимо изменены.</p>
		 <p>Способ синхронизации данных зависит от делаемых дополнительных предположений. Главной проблемой тут является то, что независимо сделанные изменения могут быть несовместимы друг с другом (так называемый «конфликт правок»), и даже теоретически не существует общего способа разрешения подобных ситуаций.</p>
		 <p>Тем не менее, есть ряд частных способов, применимых в тех или иных случаях:</p>
		 <ul>
			 <li>Наиболее простой способ: <i>предполагают, что изменения вносились лишь в одну из копий</i> — «рабочую» — и другая копия просто перезаписывается её содержимым. Этот способ реализуют большинство приложений синхронизации; в силу необратимости делаемых изменений пользователю даётся выбор, какую копию считать «главной».</li>
			 <li>
				 Если данные представляют собой набор независимых записей (то есть любое сочетание записей является корректным — это, напр., телефонная книга), то можно просто <i>объединить множества записей</i>. Это ликвидирует риск потери информации, но чтобы удалить запись из набора, этот способ приходится сочетать с первым.
				 <ul>
					 <li>Если наборы синхронизируются неоднократно, можно автоматически вводить в них <i>дополнительную служебную информацию</i>: дата и время последнего изменения записи, пометки об удалённых записях (стираются после следующей синхронизации или через достаточно большое время) и пр. . Этот подход используется, например, в Outlook.</li>
				 </ul>
			 </li>
			 <li><i>Обрабатывать конфликты правок</i>: автоматически (если возможно), иначе — вручную. Этот, наиболее общий способ применяется только если указанные выше упрощённые недопустимы — например, в системах контроля версий. Так, CVS при обнаружении двух независимых изменений объявляет о «конфликте» и либо (в простых случаях) разрешает его автоматически, либо предоставляет пользователю разрешить его вручную. В этих случаях конфликтов стараются просто избегать — например, распределением областей компетенции.</li>
		 </ul>
		 <p>Одним из механизмов синхронизации данных является репликация, которая в частности находит применение для синхронизации содержимого баз данных.</p>
		 <p><b>Синхронизация передачи данных</b> - процесс, при котором приемник синхронизируется с передатчиком в процессе передачи цифровых данных.</p>
		 <h2>Эффективность параллельной программы</h2>
		 <p>Применение суперЭВМ налагает особые требования на вновь создаваемые программные средства, обеспечивающие надежную и экономичную реализацию алгоритма при решении прикладных задач. Эффективность использования супер ЭВМ проявляется при создании сложных исследовательских комплексов и экспертных систем.</p>
		 <p>Написать эффективную параллельную программу намного труднее, чем последовательную. Создание программного обеспечения для параллельных компьютеров - это центральная проблема суперкомпьютерных вычислений.</p>
		 <p>Частично проблема выбора оптимального числа параллельных ветвей в соответствии с критерием минимума суммарных затрат времени может быть решена в автоматах генерации параллельной программы.</p>
		 <p>Эффективность использования многопроцессорных вычислительных систем в значительной мере определяется качеством прикладных параллельных программ. Программа считается эффективной, когда во время ее выполнения загружены все процессоры, выделенные под процессы. Но практически это не реализуемо.</p>
		 <h2>Свойства идеальной параллельной программы</h2>
		 <p>Отметим, что идеальная параллельная программа обладает следующими свойствами:</p>
		 <ol>
			 <li>Длины параллельно выполняемых ветвей равны между собой.</li>
			 <li>Полностью исключены простои из-за ожидания данных, передачи управления и возникновения конфликтов при использовании общих ресурсов.</li>
			 <li>Обмен данными полностью совмещен с вычислениями.</li>
		 </ol>
		 <p>Увеличение степени эффективности параллелизма (уменьшение временных затрат на накладные расходы) достигается следующими способами:</p>
		 <ul>
			 <li>укрупнением единиц распараллеливания;</li>
			 <li>уменьшением сложности алгоритмов генерации параллельных процедур (подпрограмм);</li>
			 <li>изначальной подготовкой пакета различных вариантов исходных данных;</li>
			 <li>распараллеливанием алгоритмов генерации параллельных процедур (подпрограмм).</li>
		 </ul>
		 <h2>Адаптации программ к архитектуре параллельных компьютеров</h2>
		 <p>Основные этапы самого процесса адаптации программ к архитектуре параллельных компьютеров, а также описание задач, возникающих на каждом из этих этапов, представлены в статье Антонова А.С. "Эффективная адаптация последовательных программ для современных векторно-конвеерных и массивно- параллельных супер-ЭВМ". На некоторые из задач, с которыми столкнулись авторы проведенного исследования, хотелось бы обратить особое внимание. Среди них:</p>
		 <ul>
			 <li>исследование общей структуры программы;</li>
			 <li>выделение основного вычислительного ядра, локализация ввода-вывода;</li>
			 <li>определение потенциального параллелизма фрагмента;</li>
			 <li>выделение последовательных фрагментов вычислений и попытка использования альтернативных алгоритмов для таких фрагментов;</li>
			 <li>определение и минимизация точек перераспределения данных;</li>
			 <li>преобразование традиционных циклов под параллельные алгоритмы;</li>
			 <li>минимизация числа и объема временных массивов для оптимизации работы с кэш-памятью;</li>
			 <li>переход от исходной программы, работающей с полными массивами, к программе, обрабатывающей только локальную порцию, распределенную на процессор: изменение размеров массивов и соответствующее преобразование текста программы.</li>
		 </ul>
		 <p>Отметим, что решение этих задач позволяет осуществить эффективный перенос последовательной программы на параллельную архитектуру.</p>
		 <p>Процесс разработки параллельной программы очень длителен и трудоемок, не смотря на то, что, как правило, на момент ее создания уже имеется реализация ее "последовательного" аналога. Обычно программа разрабатывается на машине с одной архитектурой, а ее практическое применение производится на другой, с отличной от первой топологией, но при этом более мощной. Такой подход позволяет экономить машинное время на более мощных суперЭВМ, число которых на порядок меньше, по сравнению с более дешевыми моделями суперкомпьютеров.</p>
		 <p>При переносе параллельной программы на машины с различной архитектурой перед программистом встает проблема неработоспособности однажды разработанных параллельных процедур.</p>
		 <p>На сегодняшний день не существует универсальных средств адаптации программ к конкретной архитектуре суперЭВМ, поэтому большую часть этой проблемы приходится решать вручную, что делает процесс очень трудоемким. Для облегчения труда программиста в математических институтах РАН разрабатываются библиотеки эффективных процедур и алгоритмов под конкретные архитектуры суперЭВМ (УРО РАН, НИВЦ МГУ им. М.В.Ломоносова). Обращение к этим библиотекам может частично облегчить труд программиста-прикладника не только на этапе модификации программы под более мощные суперЭВМ, но и на этапе первичной разработки параллельной программы.</p>
	 </div>
      <!-- gallery end -->


	<!-- footer start -->
    <div class="templatemo_footer">
    	<div class="container">
    	<div class="row">
        	<div class="col-md-9 col-sm-12">
            	<span>MukashevCorp &copy; 2019 OSPU | MOAIS</span>
            </div>
            <div class="col-md-3 col-sm-12 templatemo_rfooter">
            	  <a href="https://vk.com/art_m_m">
                 	<div class="hex_footer">
					<span class="fa fa-facebook"></span>
					</div>
                  </a>
            </div>
        </div>
        </div>
    </div>
    <!-- footer end -->    
	<script>
	$('.gallery_more').click(function(){
		var $this = $(this);
		$this.toggleClass('gallery_more');
		if($this.hasClass('gallery_more')){
			$this.text('Показать больше');
		} else {
			$this.text('Показать меньше');
		}
	});
    </script>
	<!-- templatemo 400 polygon -->
  </body>
</html>