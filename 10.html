<!DOCTYPE html>
  <head>
    <title>Интерактивный учебник</title>
    <meta name="keywords" content="" />
	<meta name="description" content="" />
    <!-- 
    Polygon Template
    https://templatemo.com/tm-400-polygon
    -->
    <meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=10, user-scalable=yes">
    
    <!-- Bootstrap -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="css/templatemo_misc.css">
    <link href="css/templatemo_style.css" rel="stylesheet">
    <link href='http://fonts.googleapis.com/css?family=Raleway:400,100,600' rel='stylesheet' type='text/css'>
      
    <script src="js/jquery-1.10.2.min.js"></script> 
	<script src="js/jquery.lightbox.js"></script>
	<script src="js/templatemo_custom.js"></script>
    <script>
    function showhide()
    {
    	var div = document.getElementById("newpost");
		if (div.style.display !== "none")
		{
			div.style.display = "none";
		}
		else {
			div.style.display = "block";
		}
    }
  	</script>
  </head>
  <body>
  	<div class="site-header">
		<div class="main-navigation">
			<div class="responsive_menu">
				<ul>
					<li><a href="index.html">На главную</a></li>
				</ul>
			</div>
			<div class="container">
				<div class="row templatemo_gallerygap">
					<div class="col-md-12 responsive-menu">
						<a href="#" class="menu-toggle-btn">
				            <i class="fa fa-bars"></i>
				        </a>
					</div> <!-- /.col-md-12 -->
                    <div class="col-md-3 col-sm-12">
                    	<a href="index.html"><img src="images/templatemo_logo.png" alt="Polygon HTML5 Template"></a>
                    </div>
					<div class="col-md-9 main_menu">
						<ul>
							<li><a href="index.html">
                            	<span class="fa fa-book"></span>
                                На главную</a></li>
						</ul>
					</div> <!-- /.col-md-12 -->
				</div> <!-- /.row -->
			</div> <!-- /.container -->
		</div> <!-- /.main-navigation -->
	</div> <!-- /.site-header -->
    <div id="menu-container">
    <!-- gallery start -->
     <div class="container">
		 <h2>10. Анализ параллельных программ. Основные понятия</h2>
		 <a class="fa fa-book" href="https://docplayer.ru/43886628-Osnovnye-ponyatiya-parallelnyh-vychisleniy.html"> Источник 1</a>
		 |
		 <a class="fa fa-book" href="https://www.intuit.ru/studies/professional_skill_improvements/2065/courses/190/lecture/4944?page=3"> Источник 2</a>
		 |
		 <a class="fa fa-book" href="https://cyberleninka.ru/article/n/sredstva-analiza-parallelnyh-spmd-programm"> Источник 3</a>

		 <p>Во многих программах, связанных с математическим моделированием,
			 приходится практически одинаковым образом обрабатывать большие массивы данных. Так
			 что особый интерес представляет анализ существующих последовательных программ на
			 параллелизм по данным. Распараллеливание по данным предполагает разделение
			 массивов на зоны, каждая из которых обрабатывается отдельным исполнителем, — так
			 называемые зоны ответственности исполнителей. Подобные вычисления обычно
			 реализуется в последовательном коде с помощью операторов цикла. В работе
			 рассматривается способ определения наличия зависимостей по данным для циклов,
			 работающих с массивами, и влияние этих зависимостей на возможность параллельного
			 выполнения циклов.
		 </p>
		 <p>Пусть тело цикла состоит из двух операторов S1 и S2, в наборы входных и/или
			 выходных данных которых входит обращение к элементам одного и того же одномерного
			 массива данных A</p>
		 <pre>for (int i=0; i&#60i_fin; ++i) {
S1: ….(A[f(i)])...
S2: ...A[g(i)]...
}</pre>
		 <p>Здесь f (i) и g(i) — некоторые целочисленные функции целого переменного. Для
			 простоты будем считать, что индекс массива A может принимать любое целое значение.
			 Нашей основной задачей является выяснение того, можно ли разбить итерационное
			 пространство такого цикла — целочисленный отрезок [1, jfin] — на зоны ответственности
			 для параллельного выполнения. Вспомним, что на самом деле оператор цикла — это
			 просто форма сокращения исходного текста программы. Если убрать это сокращение и
			 развернуть цикл, то получим:
		 </p>
		 <pre>S1,1: ….(A[f(1)])...
S2,1: ...A[g(1)]...
S1,2: ….(A[f(2)])...
S2,2: ...A[g(2)]...
...
S1,i_fin: ….(A[f(i_fin)])...
S2,i_fin: ...A[g(i_fin)]...		 </pre>
		 <p>В такой развернутой последовательности следующих друг за другом операторов
			 можно провести анализ их совокупности на зависимость по данным. Будем полагать, что
			 для одного оператора в теле цикла обращение к элементу массива A входит в набор
			 входных переменных, а для другого — в набор выходных элементов.</p>
		 <p>Без ограничения общности получаем цикл:</p>
		 <pre>for (int i=0; i&#60i_fin; ++i) {
S1: A[f(i)] = ….
S2: …. = ...A[g(i)]...
}</pre>
		 <p>В простых случаях, например, когда f и g — линейные функции, определить,
			 существует ли решение, и каково оно, конечно, возможно, но в общем случае — нет. Если
			 решения не существует, то все операторы развернутого цикла независимы друг от друга и
			 могут быть выполнены одновременно различными исполнителями, скажем, каждая
			 итерация цикла — на своем исполнителе.</p>
		 <h4>Анализ зависимостей во вложенных циклах</h4>
		 <p>В современных научных исследованиях часто рассматриваются задачи, имеющие
			 более одного измерения. При построении математических моделей таких задач
			 приходится использовать многомерные массивы данных, а для их обработки в
			 программах, реализующих построенные модели, — применять вложенные циклы. Нам
			 необходимо уметь применять к подобным программным конструкциям аппарат анализа
			 зависимостей по данным для возможного распараллеливания последовательного кода.</p>
		 <p>Рассмотрим нормализованный цикл:</p>
		 <pre>for (int j1=0; j1&#60u1; ++j1) {
for (int j2=0; j2&#60u2; ++j2) {
….
for (int jn=0; jn&#60un; ++jn) {
}
}
}</pre>
		 <p>В таких циклах конкретная итерация определяется совокупностью значений всех
			 счетчиков j1 , j2 , . . . , jn . Будем рассматривать их набор как n-мерный вектор J = (j1 , j2 , .
			 . . , jn ) и назовем его итерационным вектором. Множество всех допустимых значений
			 итерационных векторов образует итерационное пространство цикла. В этом пространстве
			 между векторами можно ввести отношения порядка. Будем говорить, что I = J, если ∀k, 1
			 ≤ k ≤ n, ik = jk , и что I < J в том случае, когда ∃s, 1 ≤ s ≤ n, такое что ∀k, 1 ≤ k < s, ik = jk ,
			 а is < js. Как и в случае с одномерным циклом предположим, что тело цикла состоит из
			 двух операторов S1 и S2, в наборы входных и/или выходных данных которых входит
			 обращение к элементам одного и того же массива данных A с размерностью, совпадающей
			 с количеством уровней вложенностей цикла. Пусть индексы массива могут принимать
			 произвольные целочисленные значения. При этом для простоты допустим, что для
			 оператора S1 элемент массива A принадлежит к выходным переменным оператора, а для
			 оператора S2 — к входным переменным. Тогда можно представить цикл в виде:</p>
		 <pre>for (int j1=0; j1&#60j_fin1; ++j1) {
for (int j2=0; j2&#60j_fin2; ++j2) {
….
for (int jn=0; jn&#60i_finn; ++jn) {
S1: A[f1(J),...,fn(J)] = ….
S2: …. = … A[g1(J),...,gn(J)] ...
}
}
}</pre>
		 <p>Здесь функции fk (J) и gk (J), 1 ≤ k ≤ n, есть целочисленные функции от n целых
			 переменных. Задачей является выяснение возможности разбиения итерационного
			 пространства такого цикла на зоны ответственности для параллельного выполнения.</p>
		 <p>Понятно, что условия Бернстайна нарушаются. Зависимость возникает, если
			 имеет решение система уравнений F(K) = G(Λ), где F — вектор-функция (f1, . . . , fn ), а G
			 — вектор-функция (g1 , . . . , gn ).</p>
		 <p>Введем для цикла понятие вектора расстояний зависимости (или просто вектора
			 расстояний) следующим образом: D = Λ − K (из вектора итераций, соответствующего
			 итерации стока зависимости, вычитаем вектор итерации, соответствующий итерации
			 источника зависимости).</p>
		 <p>Определить тип существующей зависимости по данным и возможность
			 распараллеливания цикла по виду вектора расстояний не так просто. Поэтому вводится
			 понятие вектора направлений для цикла. Компоненты вектора направлений d (а это —
			 символьный вектор) определяются следующим образом:</p>
		 <ul>
			 <li>di = „ = “, Di = 0;</li>
			 <li>di = „ > “, Di < 0;</li>
			 <li>di = „ <“, Di > 0.</li>
		 </ul>
		 <p>Если многомерный цикл имеет вектор направлений d = („=“, . . . , „=“), то цикл
			 может быть распараллелен по произвольному количеству индексов без всяких
			 ограничений. При этом циклы, соответствующие различным уровням вложенности
			 первоначальной конструкции, можно безопасно менять местами.</p>
		 <p>Для произвольного цикла возможно распараллеливание по любому индексу,
			 соответствующему компоненту „=“ в векторе направлений. Уровень вложенности,
			 соответствующий этому компоненту, можно поменять местами с любым соседним
			 уровнем вложенности с сохранением результата вычислений. Два соседних уровня
			 вложенности, которым соответствуют одинаковые компоненты вектора направлений,
			 также можно поменять местами. Если в цикле существует антизависимость, то
			 распараллеливание возможно по произвольному количеству индексов при дублировании
			 необходимых входных данных. Распараллеливание для циклов с истинной зависимостью
			 может быть проблематично.</p>
		 <h4>Практическая часть (пример)</h4>
		 <p>Основным заданием данной работы является разработка и
			 исследование параллельной программы на основе существующей готовой
			 последовательной. Полученные результаты требуется сравнить, а так же изобразить
			 графически для каждой из реализаций зависимость коэффициента ускорения программы
			 от количества используемых исполнителей</p>
		 <pre>#include &#60stdio.h>
#include &#60stdlib.h>
#define ISIZE 1000
#define JSIZE 1000
int main(int argc, char **argv)
{
double a[ISIZE][JSIZE];
int i, j;
FILE *ff;
for (i=0; i&#60ISIZE; i++){
for (j=0; j&#60JSIZE; j++){
a[i][j] = 10*i +j;
}
}
for (i=0; i&#60ISIZE; i++){
for (j = 0; j < JSIZE; j++){
a[i][j] = sin(0.00001*a[i][j]);
}
}
ff = fopen("result.txt","w");
for(i=0; i < ISIZE; i++){
for (j=0; j < JSIZE; j++){
fprintf(ff,"%f ",a[i][j]);
}
fprintf(ff,"\n");
}
fclose(ff);
}</pre>
	 </div>
      <!-- gallery end -->


	<!-- footer start -->
    <div class="templatemo_footer">
    	<div class="container">
    	<div class="row">
        	<div class="col-md-9 col-sm-12">
            	<span>MukashevCorp &copy; 2019 OSPU | MOAIS</span>
            </div>
            <div class="col-md-3 col-sm-12 templatemo_rfooter">
            	  <a href="https://vk.com/art_m_m">
                 	<div class="hex_footer">
					<span class="fa fa-facebook"></span>
					</div>
                  </a>
            </div>
        </div>
        </div>
    </div>
    <!-- footer end -->    
	<script>
	$('.gallery_more').click(function(){
		var $this = $(this);
		$this.toggleClass('gallery_more');
		if($this.hasClass('gallery_more')){
			$this.text('Показать больше');
		} else {
			$this.text('Показать меньше');
		}
	});
    </script>
	<!-- templatemo 400 polygon -->
  </body>
</html>